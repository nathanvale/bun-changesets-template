---
name: Consolidate external service mocks to boundary adapters
status: open
created: 2025-09-20T01:15:53Z
updated: 2025-09-20T01:15:53Z
github: [Will be updated when synced to GitHub]
depends_on: [003, 011]
parallel: true
conflicts_with: []
---

# Task 018: Consolidate external service mocks to boundary adapters

## Description

Consolidate scattered external service mocks into centralized boundary adapters
that provide clean interfaces for testing. This reduces mock duplication,
improves consistency, and creates clear boundaries between our system and
external dependencies.

External services (APIs, databases, file systems) should be mocked only at
well-defined boundary points, not scattered throughout individual tests. This
approach simplifies testing, improves maintainability, and makes external
service interactions more predictable.

## Acceptance Criteria

1. **Boundary Identification**
   - [ ] Identify all external service interaction points
   - [ ] Map current scattered external service mocks
   - [ ] Design clean boundary adapter interfaces
   - [ ] Document external service dependencies

2. **Adapter Implementation**
   - [ ] Create boundary adapters for each external service type
   - [ ] Implement test doubles for all adapters
   - [ ] Establish consistent patterns for external service mocking
   - [ ] Ensure adapters support both real and test implementations

3. **Mock Consolidation**
   - [ ] Replace scattered mocks with centralized adapter usage
   - [ ] Migrate tests to use boundary adapters
   - [ ] Remove duplicate external service mocking code
   - [ ] Maintain test coverage and functionality

4. **Testing Infrastructure**
   - [ ] Create adapter test utilities and factories
   - [ ] Implement configuration-based adapter selection
   - [ ] Establish patterns for adapter integration testing
   - [ ] Document adapter usage and testing patterns

## Technical Details

### External Service Categories

1. **HTTP/API Services**

   ```typescript
   // BEFORE: Scattered fetch mocking
   // In multiple test files:
   global.fetch = vi.fn().mockResolvedValue({
     ok: true,
     json: () => Promise.resolve({ data: 'test' }),
   })

   // AFTER: Centralized HTTP adapter
   export interface HttpAdapter {
     get<T>(url: string, options?: RequestOptions): Promise<T>
     post<T>(url: string, body: any, options?: RequestOptions): Promise<T>
     put<T>(url: string, body: any, options?: RequestOptions): Promise<T>
     delete<T>(url: string, options?: RequestOptions): Promise<T>
   }

   export class TestHttpAdapter implements HttpAdapter {
     private responses = new Map<string, any>()

     mockResponse(pattern: string, response: any): void {
       this.responses.set(pattern, response)
     }

     async get<T>(url: string): Promise<T> {
       return this.getMockResponse(url)
     }
   }
   ```

2. **Database Services**

   ```typescript
   // BEFORE: Database mocking in every test
   vi.mock('pg', () => ({
     Client: vi.fn().mockImplementation(() => ({
       connect: vi.fn(),
       query: vi.fn().mockResolvedValue({ rows: [] }),
       end: vi.fn(),
     })),
   }))

   // AFTER: Database adapter
   export interface DatabaseAdapter {
     query<T>(sql: string, params?: any[]): Promise<T[]>
     transaction<T>(fn: (tx: Transaction) => Promise<T>): Promise<T>
     close(): Promise<void>
   }

   export class TestDatabaseAdapter implements DatabaseAdapter {
     private data = new Map<string, any[]>()

     setTableData(table: string, data: any[]): void {
       this.data.set(table, data)
     }

     async query<T>(sql: string, params?: any[]): Promise<T[]> {
       // Mock query execution with test data
       return this.executeTestQuery(sql, params)
     }
   }
   ```

3. **File System Services**

   ```typescript
   // BEFORE: fs mocking everywhere
   vi.mock('fs/promises', () => ({
     readFile: vi.fn().mockResolvedValue('file content'),
     writeFile: vi.fn().mockResolvedValue(undefined),
     mkdir: vi.fn().mockResolvedValue(undefined),
   }))

   // AFTER: File system adapter
   export interface FileSystemAdapter {
     readFile(path: string, encoding?: string): Promise<string>
     writeFile(path: string, content: string): Promise<void>
     mkdir(path: string, options?: any): Promise<void>
     exists(path: string): Promise<boolean>
   }

   export class TestFileSystemAdapter implements FileSystemAdapter {
     private files = new Map<string, string>()

     setFile(path: string, content: string): void {
       this.files.set(path, content)
     }

     async readFile(path: string): Promise<string> {
       return this.files.get(path) || ''
     }
   }
   ```

4. **Email Services**

   ```typescript
   // BEFORE: Email service mocking in tests
   vi.mock('../services/email-service', () => ({
     sendEmail: vi.fn().mockResolvedValue({ messageId: 'test' }),
   }))

   // AFTER: Email adapter
   export interface EmailAdapter {
     sendEmail(to: string, subject: string, body: string): Promise<EmailResult>
     sendTemplate(to: string, template: string, data: any): Promise<EmailResult>
   }

   export class TestEmailAdapter implements EmailAdapter {
     private sentEmails: EmailMessage[] = []

     async sendEmail(
       to: string,
       subject: string,
       body: string,
     ): Promise<EmailResult> {
       this.sentEmails.push({ to, subject, body, timestamp: new Date() })
       return { messageId: `test-${this.sentEmails.length}` }
     }

     getSentEmails(): EmailMessage[] {
       return [...this.sentEmails]
     }
   }
   ```

### Adapter Design Patterns

1. **Interface Segregation**

   ```typescript
   // Separate interfaces for different concerns
   export interface ReadOnlyDatabaseAdapter {
     query<T>(sql: string, params?: any[]): Promise<T[]>
   }

   export interface WritableDatabaseAdapter extends ReadOnlyDatabaseAdapter {
     insert<T>(table: string, data: T): Promise<T>
     update<T>(table: string, id: any, data: Partial<T>): Promise<T>
     delete(table: string, id: any): Promise<void>
   }
   ```

2. **Configuration-Based Selection**

   ```typescript
   // Adapter factory based on environment
   export class AdapterFactory {
     static createHttpAdapter(): HttpAdapter {
       if (process.env.NODE_ENV === 'test') {
         return new TestHttpAdapter()
       }
       return new ProductionHttpAdapter()
     }

     static createDatabaseAdapter(): DatabaseAdapter {
       if (process.env.NODE_ENV === 'test') {
         return new TestDatabaseAdapter()
       }
       return new ProductionDatabaseAdapter()
     }
   }
   ```

3. **Dependency Injection Integration**

   ```typescript
   // Service using adapters
   export class UserService {
     constructor(
       private database: DatabaseAdapter,
       private email: EmailAdapter,
       private fileSystem: FileSystemAdapter,
     ) {}

     async createUser(userData: UserData): Promise<User> {
       // Use adapters instead of direct external service calls
       const user = await this.database.insert('users', userData)
       await this.email.sendEmail(user.email, 'Welcome', 'Welcome message')
       return user
     }
   }

   // Test setup
   const userService = new UserService(
     new TestDatabaseAdapter(),
     new TestEmailAdapter(),
     new TestFileSystemAdapter(),
   )
   ```

### Migration Strategy

1. **Adapter Creation Phase**

   ```typescript
   // 1. Create adapter interfaces
   // 2. Implement production adapters
   // 3. Implement test adapters
   // 4. Create adapter factories
   ```

2. **Service Migration Phase**

   ```typescript
   // Replace direct external service usage with adapters
   // BEFORE
   import fetch from 'node-fetch'

   export class ApiService {
     async getData(): Promise<any> {
       const response = await fetch('https://api.example.com/data')
       return response.json()
     }
   }

   // AFTER
   export class ApiService {
     constructor(private http: HttpAdapter) {}

     async getData(): Promise<any> {
       return this.http.get('https://api.example.com/data')
     }
   }
   ```

3. **Test Migration Phase**

   ```typescript
   // Replace scattered mocks with adapter usage
   describe('User Service', () => {
     let userService: UserService
     let testDatabase: TestDatabaseAdapter
     let testEmail: TestEmailAdapter

     beforeEach(() => {
       testDatabase = new TestDatabaseAdapter()
       testEmail = new TestEmailAdapter()
       userService = new UserService(testDatabase, testEmail)
     })

     it('creates user and sends welcome email', async () => {
       testDatabase.setTableData('users', [])

       const user = await userService.createUser(testUserData)

       expect(user.id).toBeDefined()
       expect(testEmail.getSentEmails()).toHaveLength(1)
     })
   })
   ```

### Consolidation Benefits

1. **Reduced Duplication**
   - Single source of truth for external service interfaces
   - Consistent mocking patterns across tests
   - Reusable test adapters
   - Centralized configuration

2. **Improved Maintainability**
   - Changes to external services require updates in one place
   - Consistent error handling patterns
   - Easier to upgrade external service versions
   - Better debugging capabilities

3. **Enhanced Testing**
   - More realistic test scenarios
   - Better external service simulation
   - Easier integration testing
   - Improved test reliability

## Dependencies

- **Task 003**: Test infrastructure must support adapter patterns
- **Task 011**: External service mocks must be identified and categorized
- **Parallel Execution**: Safe for parallel execution as it's additive

## Effort Estimate

**Size**: Large (3 days)

**Breakdown**:

- Day 1: Design adapters and implement core interfaces
- Day 2: Create test adapters and migration utilities
- Day 3: Migrate existing tests and validate functionality

**Skills Required**:

- Adapter pattern expertise
- External service integration knowledge
- Dependency injection understanding
- Test infrastructure development

## Definition of Done

1. **Complete Adapter Infrastructure**
   - Adapters for all major external service types
   - Test implementations for all adapters
   - Configuration-based adapter selection
   - Comprehensive adapter documentation

2. **Mock Consolidation Achievement**
   - Scattered external service mocks replaced with adapters
   - Consistent patterns for external service testing
   - Reduced code duplication in tests
   - Improved test maintainability

3. **Enhanced Service Architecture**
   - Clear boundaries between internal and external systems
   - Improved dependency injection patterns
   - Better separation of concerns
   - More testable service implementations

4. **Testing Improvements**
   - Consistent external service mocking across tests
   - Easier integration testing setup
   - Better test isolation and reliability
   - Simplified test configuration

5. **Documentation and Standards**
   - Adapter usage guidelines
   - External service testing patterns
   - Migration guide for future services
   - Best practices for adapter design

The implementation must demonstrate that external service interactions can be
effectively managed through centralized adapters, reducing mock complexity while
improving system architecture and test quality.
