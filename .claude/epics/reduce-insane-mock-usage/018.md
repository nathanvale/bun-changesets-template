---
epic: reduce-insane-mock-usage
task: 018
title: Consolidate external service mocks to boundary adapters
size: Large
parallel: true
depends_on: [011]
status: pending
created: 2025-09-20T02:15:00Z
updated: 2025-09-20T02:15:00Z
---

# Task 018: Consolidate external service mocks to boundary adapters

## Objective

Consolidate scattered external service mocks into centralized boundary adapters,
implementing the "mock at trust boundaries" principle to reduce mock
proliferation while maintaining proper isolation from external dependencies.

## Background

External service mocks are currently scattered throughout the test suite,
creating maintenance overhead and inconsistent behavior. By consolidating these
mocks into boundary adapters, we achieve better organization, consistency, and
easier maintenance while still properly isolating our code from external
dependencies.

## Requirements

### 1. External Service Mock Audit

Identify all external service mocks:

- **HTTP API mocks** (REST services, GraphQL endpoints)
- **Database service mocks** (external databases, cloud services)
- **File storage mocks** (S3, cloud storage, CDN services)
- **Email service mocks** (SendGrid, SES, SMTP services)
- **Payment service mocks** (Stripe, PayPal, payment gateways)
- **Authentication service mocks** (OAuth providers, SAML, SSO)

### 2. Boundary Adapter Design

Create standardized adapters:

- **Interface-based design**: Clear contracts for external services
- **Configuration-driven**: Easy switching between real and test implementations
- **Centralized mock management**: Single source of truth for external service
  behavior
- **Environment-aware**: Different behaviors for test, development, and
  production

### 3. Mock Consolidation Strategy

- **Extract common patterns**: Identify repeated mock behaviors
- **Create reusable adapters**: Build adapters that can be used across tests
- **Implement test utilities**: Provide easy-to-use test setup functions
- **Maintain backward compatibility**: Gradual migration without breaking
  existing tests

## Implementation Details

### 1. External Service Mock Scanner

```typescript
// scripts/external-service-mock-scanner.ts

interface ExternalServiceMock {
  file: string
  line: number
  service: ExternalService
  mockType: 'http' | 'client' | 'sdk' | 'direct'
  complexity: 'simple' | 'moderate' | 'complex'
  usagePattern: MockUsagePattern
  consolidationPotential: 'high' | 'medium' | 'low'
  dependencies: string[]
}

enum ExternalService {
  HTTP_API = 'http-api',
  DATABASE = 'database',
  FILE_STORAGE = 'file-storage',
  EMAIL = 'email',
  PAYMENT = 'payment',
  AUTH = 'auth',
  ANALYTICS = 'analytics',
  NOTIFICATION = 'notification',
}

interface MockUsagePattern {
  pattern:
    | 'success-response'
    | 'error-response'
    | 'complex-flow'
    | 'state-dependent'
  frequency: number
  variations: string[]
}

class ExternalServiceMockScanner {
  async scanExternalServiceMocks(
    testDir: string,
  ): Promise<ExternalServiceMock[]> {
    const testFiles = await this.findTestFiles(testDir)
    const externalMocks: ExternalServiceMock[] = []

    for (const file of testFiles) {
      const content = await fs.readFile(file, 'utf-8')
      const fileMocks = this.findExternalServiceMocks(file, content)
      externalMocks.push(...fileMocks)
    }

    return this.analyzeConsolidationOpportunities(externalMocks)
  }

  private findExternalServiceMocks(
    file: string,
    content: string,
  ): ExternalServiceMock[] {
    const mocks: ExternalServiceMock[] = []
    const lines = content.split('\n')

    lines.forEach((line, index) => {
      // HTTP/API mocks
      if (this.isHttpMock(line)) {
        mocks.push({
          file,
          line: index + 1,
          service: ExternalService.HTTP_API,
          mockType: this.determineHttpMockType(line),
          complexity: this.assessHttpMockComplexity(content, index),
          usagePattern: this.analyzeUsagePattern(content, index),
          consolidationPotential: 'high',
          dependencies: this.extractDependencies(content, index),
        })
      }

      // External client/SDK mocks
      if (this.isExternalClientMock(line)) {
        const service = this.identifyExternalService(line)
        mocks.push({
          file,
          line: index + 1,
          service,
          mockType: 'client',
          complexity: this.assessClientMockComplexity(content, index),
          usagePattern: this.analyzeUsagePattern(content, index),
          consolidationPotential: this.assessConsolidationPotential(
            service,
            content,
          ),
          dependencies: this.extractDependencies(content, index),
        })
      }

      // Direct service mocks
      if (this.isDirectServiceMock(line)) {
        const service = this.identifyServiceFromMock(line)
        mocks.push({
          file,
          line: index + 1,
          service,
          mockType: 'direct',
          complexity: this.assessDirectMockComplexity(content, index),
          usagePattern: this.analyzeUsagePattern(content, index),
          consolidationPotential: this.assessConsolidationPotential(
            service,
            content,
          ),
          dependencies: this.extractDependencies(content, index),
        })
      }
    })

    return mocks
  }

  private isHttpMock(line: string): boolean {
    const httpMockIndicators = [
      'vi.mock.*axios',
      'vi.mock.*fetch',
      'vi.mock.*http',
      'vi.mock.*request',
      'http.get',
      'http.post',
      'msw',
      'nock',
    ]

    return httpMockIndicators.some((indicator) =>
      new RegExp(indicator, 'i').test(line),
    )
  }

  private isExternalClientMock(line: string): boolean {
    const externalClients = [
      'aws-sdk',
      'stripe',
      'sendgrid',
      'twilio',
      'google-apis',
      'mongodb',
      'redis',
      'elasticsearch',
      'firebase',
    ]

    return externalClients.some(
      (client) =>
        line.includes(`vi.mock.*${client}`) ||
        line.includes(`vi.mock('${client}`),
    )
  }

  private identifyExternalService(line: string): ExternalService {
    const serviceMap = {
      'aws-sdk': ExternalService.FILE_STORAGE,
      'stripe': ExternalService.PAYMENT,
      'sendgrid': ExternalService.EMAIL,
      'twilio': ExternalService.NOTIFICATION,
      'google-apis': ExternalService.AUTH,
      'mongodb': ExternalService.DATABASE,
      'redis': ExternalService.DATABASE,
      'elasticsearch': ExternalService.DATABASE,
      'firebase': ExternalService.AUTH,
    }

    for (const [client, service] of Object.entries(serviceMap)) {
      if (line.includes(client)) {
        return service
      }
    }

    return ExternalService.HTTP_API
  }

  private analyzeConsolidationOpportunities(
    mocks: ExternalServiceMock[],
  ): ExternalServiceMock[] {
    // Group by service type and analyze patterns
    const serviceGroups = this.groupByService(mocks)

    Object.entries(serviceGroups).forEach(([service, serviceMocks]) => {
      const patterns = this.identifyCommonPatterns(serviceMocks)
      const consolidationPotential =
        this.calculateConsolidationPotential(patterns)

      serviceMocks.forEach((mock) => {
        mock.consolidationPotential = consolidationPotential
      })
    })

    return mocks
  }

  private identifyCommonPatterns(mocks: ExternalServiceMock[]): Array<{
    pattern: string
    frequency: number
    examples: string[]
  }> {
    const patternMap = new Map<
      string,
      { frequency: number; examples: string[] }
    >()

    mocks.forEach((mock) => {
      const pattern = this.extractMockPattern(mock)
      if (!patternMap.has(pattern)) {
        patternMap.set(pattern, { frequency: 0, examples: [] })
      }

      const entry = patternMap.get(pattern)!
      entry.frequency++
      entry.examples.push(`${mock.file}:${mock.line}`)
    })

    return Array.from(patternMap.entries()).map(([pattern, data]) => ({
      pattern,
      frequency: data.frequency,
      examples: data.examples,
    }))
  }
}
```

### 2. Boundary Adapter Framework

```typescript
// src/adapters/base/external-service-adapter.ts

export abstract class ExternalServiceAdapter<TConfig = any, TClient = any> {
  protected config: TConfig
  protected client: TClient | null = null

  constructor(config: TConfig) {
    this.config = config
  }

  abstract initialize(): Promise<void>
  abstract cleanup(): Promise<void>
  abstract isHealthy(): Promise<boolean>

  protected abstract createClient(): TClient

  async getClient(): Promise<TClient> {
    if (!this.client) {
      await this.initialize()
    }
    return this.client!
  }
}

// HTTP API Adapter
export class HttpApiAdapter extends ExternalServiceAdapter<
  HttpConfig,
  AxiosInstance
> {
  private baseURL: string
  private timeout: number
  private retryConfig: RetryConfig

  constructor(config: HttpConfig) {
    super(config)
    this.baseURL = config.baseURL
    this.timeout = config.timeout || 5000
    this.retryConfig = config.retry || { attempts: 3, delay: 1000 }
  }

  async initialize(): Promise<void> {
    this.client = this.createClient()
  }

  protected createClient(): AxiosInstance {
    const client = axios.create({
      baseURL: this.baseURL,
      timeout: this.timeout,
      headers: {
        'Content-Type': 'application/json',
        ...this.config.headers,
      },
    })

    // Add retry interceptor
    client.interceptors.response.use(
      (response) => response,
      async (error) => {
        if (this.shouldRetry(error)) {
          return this.retryRequest(error)
        }
        throw error
      },
    )

    return client
  }

  async get<T>(endpoint: string, config?: AxiosRequestConfig): Promise<T> {
    const client = await this.getClient()
    const response = await client.get<T>(endpoint, config)
    return response.data
  }

  async post<T>(
    endpoint: string,
    data?: any,
    config?: AxiosRequestConfig,
  ): Promise<T> {
    const client = await this.getClient()
    const response = await client.post<T>(endpoint, data, config)
    return response.data
  }

  async put<T>(
    endpoint: string,
    data?: any,
    config?: AxiosRequestConfig,
  ): Promise<T> {
    const client = await this.getClient()
    const response = await client.put<T>(endpoint, data, config)
    return response.data
  }

  async delete<T>(endpoint: string, config?: AxiosRequestConfig): Promise<T> {
    const client = await this.getClient()
    const response = await client.delete<T>(endpoint, config)
    return response.data
  }

  async cleanup(): Promise<void> {
    // HTTP clients don't need explicit cleanup
  }

  async isHealthy(): Promise<boolean> {
    try {
      const client = await this.getClient()
      await client.get('/health')
      return true
    } catch {
      return false
    }
  }

  private shouldRetry(error: AxiosError): boolean {
    return error.response?.status ? error.response.status >= 500 : true
  }

  private async retryRequest(error: AxiosError): Promise<AxiosResponse> {
    // Implement retry logic
    await new Promise((resolve) => setTimeout(resolve, this.retryConfig.delay))
    return axios.request(error.config!)
  }
}

// Email Service Adapter
export class EmailServiceAdapter extends ExternalServiceAdapter<
  EmailConfig,
  EmailClient
> {
  async initialize(): Promise<void> {
    this.client = this.createClient()
  }

  protected createClient(): EmailClient {
    switch (this.config.provider) {
      case 'sendgrid':
        return new SendGridClient(this.config.apiKey)
      case 'ses':
        return new SESClient(this.config.credentials)
      case 'smtp':
        return new SMTPClient(this.config.smtp)
      default:
        throw new Error(`Unsupported email provider: ${this.config.provider}`)
    }
  }

  async sendEmail(message: EmailMessage): Promise<EmailResult> {
    const client = await this.getClient()
    return client.send(message)
  }

  async sendBulkEmail(messages: EmailMessage[]): Promise<EmailResult[]> {
    const client = await this.getClient()
    return client.sendBulk(messages)
  }

  async validateEmail(email: string): Promise<boolean> {
    const client = await this.getClient()
    return client.validate(email)
  }

  async cleanup(): Promise<void> {
    if (this.client) {
      await this.client.disconnect?.()
    }
  }

  async isHealthy(): Promise<boolean> {
    try {
      const client = await this.getClient()
      return await client.ping()
    } catch {
      return false
    }
  }
}

// File Storage Adapter
export class FileStorageAdapter extends ExternalServiceAdapter<
  StorageConfig,
  StorageClient
> {
  async initialize(): Promise<void> {
    this.client = this.createClient()
  }

  protected createClient(): StorageClient {
    switch (this.config.provider) {
      case 's3':
        return new S3Client(this.config.s3)
      case 'gcs':
        return new GCSClient(this.config.gcs)
      case 'azure':
        return new AzureStorageClient(this.config.azure)
      case 'local':
        return new LocalStorageClient(this.config.local)
      default:
        throw new Error(`Unsupported storage provider: ${this.config.provider}`)
    }
  }

  async uploadFile(
    key: string,
    data: Buffer | string,
    options?: UploadOptions,
  ): Promise<UploadResult> {
    const client = await this.getClient()
    return client.upload(key, data, options)
  }

  async downloadFile(key: string): Promise<Buffer> {
    const client = await this.getClient()
    return client.download(key)
  }

  async deleteFile(key: string): Promise<void> {
    const client = await this.getClient()
    await client.delete(key)
  }

  async getSignedUrl(
    key: string,
    operation: 'get' | 'put',
    expiresIn?: number,
  ): Promise<string> {
    const client = await this.getClient()
    return client.getSignedUrl(key, operation, expiresIn)
  }

  async cleanup(): Promise<void> {
    if (this.client) {
      await this.client.disconnect?.()
    }
  }

  async isHealthy(): Promise<boolean> {
    try {
      const client = await this.getClient()
      return await client.ping()
    } catch {
      return false
    }
  }
}
```

### 3. Test Adapter Factory

```typescript
// __tests__/fixtures/adapters/test-adapter-factory.ts

export class TestAdapterFactory {
  static createHttpAdapter(config: Partial<HttpConfig> = {}): HttpApiAdapter {
    const defaultConfig: HttpConfig = {
      baseURL: 'http://localhost:3000',
      timeout: 1000,
      headers: { 'X-Test': 'true' },
      retry: { attempts: 1, delay: 100 },
    }

    return new HttpApiAdapter({ ...defaultConfig, ...config })
  }

  static createEmailAdapter(
    config: Partial<EmailConfig> = {},
  ): EmailServiceAdapter {
    const defaultConfig: EmailConfig = {
      provider: 'test',
      apiKey: 'test-key',
      fromAddress: 'test@example.com',
    }

    return new EmailServiceAdapter({ ...defaultConfig, ...config })
  }

  static createFileStorageAdapter(
    config: Partial<StorageConfig> = {},
  ): FileStorageAdapter {
    const defaultConfig: StorageConfig = {
      provider: 'local',
      local: {
        basePath: '/tmp/test-storage',
        createDirectories: true,
      },
    }

    return new FileStorageAdapter({ ...defaultConfig, ...config })
  }

  static createPaymentAdapter(
    config: Partial<PaymentConfig> = {},
  ): PaymentServiceAdapter {
    const defaultConfig: PaymentConfig = {
      provider: 'test',
      testMode: true,
      apiKey: 'test-key',
    }

    return new PaymentServiceAdapter({ ...defaultConfig, ...config })
  }

  // Create mock adapters for testing
  static createMockHttpAdapter(
    behavior: 'success' | 'error' | 'custom' = 'success',
  ): HttpApiAdapter {
    const adapter = this.createHttpAdapter()

    // Override methods with mock behavior
    switch (behavior) {
      case 'success':
        adapter.get = vi.fn().mockResolvedValue({ success: true, data: {} })
        adapter.post = vi.fn().mockResolvedValue({ success: true, data: {} })
        adapter.put = vi.fn().mockResolvedValue({ success: true, data: {} })
        adapter.delete = vi.fn().mockResolvedValue({ success: true })
        break

      case 'error':
        const error = new Error('Mock HTTP error')
        adapter.get = vi.fn().mockRejectedValue(error)
        adapter.post = vi.fn().mockRejectedValue(error)
        adapter.put = vi.fn().mockRejectedValue(error)
        adapter.delete = vi.fn().mockRejectedValue(error)
        break

      case 'custom':
        // Allow custom behavior to be set by tests
        break
    }

    return adapter
  }

  static createMockEmailAdapter(
    behavior: 'success' | 'error' | 'partial' = 'success',
  ): EmailServiceAdapter {
    const adapter = this.createEmailAdapter()

    switch (behavior) {
      case 'success':
        adapter.sendEmail = vi
          .fn()
          .mockResolvedValue({ success: true, messageId: 'mock-id' })
        adapter.sendBulkEmail = vi
          .fn()
          .mockResolvedValue([{ success: true, messageId: 'mock-id' }])
        adapter.validateEmail = vi.fn().mockResolvedValue(true)
        break

      case 'error':
        const error = new Error('Mock email error')
        adapter.sendEmail = vi.fn().mockRejectedValue(error)
        adapter.sendBulkEmail = vi.fn().mockRejectedValue(error)
        adapter.validateEmail = vi.fn().mockRejectedValue(error)
        break

      case 'partial':
        adapter.sendEmail = vi
          .fn()
          .mockResolvedValue({ success: true, messageId: 'mock-id' })
        adapter.sendBulkEmail = vi.fn().mockResolvedValue([
          { success: true, messageId: 'mock-id-1' },
          { success: false, error: 'Invalid email' },
        ])
        adapter.validateEmail = vi
          .fn()
          .mockImplementation((email: string) =>
            Promise.resolve(email.includes('@')),
          )
        break
    }

    return adapter
  }

  // Create adapter configurator for complex test scenarios
  static createAdapterConfigurator(): AdapterConfigurator {
    return new AdapterConfigurator()
  }
}

export class AdapterConfigurator {
  private adapters: Map<string, ExternalServiceAdapter> = new Map()

  withHttpAdapter(name: string, config?: Partial<HttpConfig>): this {
    this.adapters.set(name, TestAdapterFactory.createHttpAdapter(config))
    return this
  }

  withEmailAdapter(name: string, config?: Partial<EmailConfig>): this {
    this.adapters.set(name, TestAdapterFactory.createEmailAdapter(config))
    return this
  }

  withStorageAdapter(name: string, config?: Partial<StorageConfig>): this {
    this.adapters.set(name, TestAdapterFactory.createFileStorageAdapter(config))
    return this
  }

  withMockBehavior<T extends ExternalServiceAdapter>(
    name: string,
    customizer: (adapter: T) => void,
  ): this {
    const adapter = this.adapters.get(name) as T
    if (adapter) {
      customizer(adapter)
    }
    return this
  }

  build(): Map<string, ExternalServiceAdapter> {
    return this.adapters
  }

  async initialize(): Promise<void> {
    await Promise.all(
      Array.from(this.adapters.values()).map((adapter) => adapter.initialize()),
    )
  }

  async cleanup(): Promise<void> {
    await Promise.all(
      Array.from(this.adapters.values()).map((adapter) => adapter.cleanup()),
    )
  }
}
```

### 4. Mock Consolidation Engine

```typescript
// scripts/mock-consolidation-engine.ts

class MockConsolidationEngine {
  async consolidateExternalServiceMocks(
    mocks: ExternalServiceMock[],
  ): Promise<ConsolidationResult> {
    const serviceGroups = this.groupMocksByService(mocks)
    const consolidationResults: ConsolidationResult[] = []

    for (const [service, serviceMocks] of Object.entries(serviceGroups)) {
      const result = await this.consolidateServiceMocks(
        service as ExternalService,
        serviceMocks,
      )
      consolidationResults.push(result)
    }

    return this.mergeConsolidationResults(consolidationResults)
  }

  private async consolidateServiceMocks(
    service: ExternalService,
    mocks: ExternalServiceMock[],
  ): Promise<ConsolidationResult> {
    // Step 1: Create boundary adapter for service
    const adapter = await this.createBoundaryAdapter(service, mocks)

    // Step 2: Update tests to use adapter
    const testUpdates = await this.updateTestsToUseAdapter(mocks, adapter)

    // Step 3: Remove original mock setups
    const mockRemovals = await this.removeOriginalMocks(mocks)

    // Step 4: Create test utilities for easy adapter usage
    const testUtilities = await this.createTestUtilities(service, adapter)

    return {
      service,
      adapterCreated: adapter,
      testsUpdated: testUpdates.length,
      mocksRemoved: mockRemovals.length,
      testUtilities,
      consolidationRatio: this.calculateConsolidationRatio(mocks, testUpdates),
    }
  }

  private async createBoundaryAdapter(
    service: ExternalService,
    mocks: ExternalServiceMock[],
  ): Promise<AdapterInfo> {
    const adapterTemplate = this.generateAdapterTemplate(service, mocks)
    const adapterPath = this.determineAdapterPath(service)

    await fs.writeFile(adapterPath, adapterTemplate)

    return {
      service,
      path: adapterPath,
      interface: this.extractAdapterInterface(adapterTemplate),
      testFactory: this.generateTestFactory(service),
    }
  }

  private generateAdapterTemplate(
    service: ExternalService,
    mocks: ExternalServiceMock[],
  ): string {
    const commonPatterns = this.extractCommonPatterns(mocks)
    const adapterMethods = this.generateAdapterMethods(commonPatterns)
    const testImplementation = this.generateTestImplementation(
      service,
      commonPatterns,
    )

    return `
// Generated boundary adapter for ${service}
import { ExternalServiceAdapter } from '../base/external-service-adapter'

export interface ${this.capitalizeService(service)}Config {
  ${this.generateConfigInterface(mocks)}
}

export interface ${this.capitalizeService(service)}Client {
  ${this.generateClientInterface(commonPatterns)}
}

export class ${this.capitalizeService(service)}Adapter extends ExternalServiceAdapter<${this.capitalizeService(service)}Config, ${this.capitalizeService(service)}Client> {
  async initialize(): Promise<void> {
    this.client = this.createClient()
  }

  protected createClient(): ${this.capitalizeService(service)}Client {
    if (this.config.testMode) {
      return new Test${this.capitalizeService(service)}Client(this.config)
    }
    return new Real${this.capitalizeService(service)}Client(this.config)
  }

  ${adapterMethods}

  async cleanup(): Promise<void> {
    if (this.client) {
      await this.client.disconnect?.()
    }
  }

  async isHealthy(): Promise<boolean> {
    try {
      return await this.client.ping()
    } catch {
      return false
    }
  }
}

${testImplementation}

export default ${this.capitalizeService(service)}Adapter
    `
  }

  private async updateTestsToUseAdapter(
    mocks: ExternalServiceMock[],
    adapter: AdapterInfo,
  ): Promise<TestUpdateResult[]> {
    const results: TestUpdateResult[] = []

    for (const mock of mocks) {
      try {
        const originalContent = await fs.readFile(mock.file, 'utf-8')
        const updatedContent = this.replaceWithAdapterUsage(
          originalContent,
          mock,
          adapter,
        )

        await fs.writeFile(mock.file, updatedContent)

        results.push({
          file: mock.file,
          success: true,
          changes: this.summarizeChanges(mock, adapter),
        })
      } catch (error) {
        results.push({
          file: mock.file,
          success: false,
          error: error.message,
        })
      }
    }

    return results
  }

  private replaceWithAdapterUsage(
    content: string,
    mock: ExternalServiceMock,
    adapter: AdapterInfo,
  ): string {
    let updatedContent = content

    // Remove original mock setup
    updatedContent = this.removeMockSetup(updatedContent, mock)

    // Add adapter import
    const adapterImport = this.generateAdapterImport(adapter)
    updatedContent = this.addImport(updatedContent, adapterImport)

    // Replace mock usage with adapter usage
    updatedContent = this.replaceUsageWithAdapter(updatedContent, mock, adapter)

    // Add adapter setup in test
    const adapterSetup = this.generateAdapterSetup(adapter)
    updatedContent = this.addTestSetup(updatedContent, adapterSetup)

    return updatedContent
  }

  private generateAdapterImport(adapter: AdapterInfo): string {
    const adapterName = this.capitalizeService(adapter.service) + 'Adapter'
    const testFactoryName = 'Test' + adapterName + 'Factory'

    return `
import { ${adapterName} } from '../../adapters/${adapter.service}/${adapter.service}-adapter'
import { ${testFactoryName} } from '../../fixtures/adapters/${adapter.service}-test-factory'
    `
  }

  private generateAdapterSetup(adapter: AdapterInfo): string {
    const adapterName = this.capitalizeService(adapter.service) + 'Adapter'
    const factoryName = 'Test' + adapterName + 'Factory'

    return `
  // Setup ${adapter.service} adapter for testing
  const ${adapter.service}Adapter = ${factoryName}.createMockAdapter('success')

  beforeEach(async () => {
    await ${adapter.service}Adapter.initialize()
  })

  afterEach(async () => {
    await ${adapter.service}Adapter.cleanup()
  })
    `
  }

  private async createTestUtilities(
    service: ExternalService,
    adapter: AdapterInfo,
  ): Promise<string> {
    const utilityPath = `__tests__/fixtures/adapters/${service}-test-utilities.ts`
    const utilityCode = this.generateTestUtilityCode(service, adapter)

    await fs.writeFile(utilityPath, utilityCode)
    return utilityPath
  }

  private generateTestUtilityCode(
    service: ExternalService,
    adapter: AdapterInfo,
  ): string {
    const adapterName = this.capitalizeService(service) + 'Adapter'

    return `
// Test utilities for ${service} adapter
import { ${adapterName} } from '../../../src/adapters/${service}/${service}-adapter'

export class Test${adapterName}Utilities {
  static createSuccessAdapter(): ${adapterName} {
    const adapter = new ${adapterName}({
      testMode: true,
      provider: 'test'
    })

    // Mock successful responses
    ${this.generateSuccessMocks(service)}

    return adapter
  }

  static createErrorAdapter(errorType: 'network' | 'auth' | 'server' = 'network'): ${adapterName} {
    const adapter = new ${adapterName}({
      testMode: true,
      provider: 'test'
    })

    // Mock error responses
    ${this.generateErrorMocks(service)}

    return adapter
  }

  static createCustomAdapter(customBehavior: Record<string, any>): ${adapterName} {
    const adapter = new ${adapterName}({
      testMode: true,
      provider: 'test'
    })

    // Apply custom behavior
    Object.entries(customBehavior).forEach(([method, behavior]) => {
      if (typeof behavior === 'function') {
        adapter[method] = behavior
      } else {
        adapter[method] = vi.fn().mockResolvedValue(behavior)
      }
    })

    return adapter
  }

  static createScenarioAdapter(scenario: '${service}-workflow'): ${adapterName} {
    const scenarios = {
      '${service}-workflow': this.create${this.capitalizeService(service)}WorkflowAdapter
    }

    return scenarios[scenario]?.() || this.createSuccessAdapter()
  }

  private static create${this.capitalizeService(service)}WorkflowAdapter(): ${adapterName} {
    // Create adapter with workflow-specific behavior
    ${this.generateWorkflowMocks(service)}
  }
}

export const ${service}TestUtils = Test${adapterName}Utilities
    `
  }
}

interface ConsolidationResult {
  service: ExternalService
  adapterCreated: AdapterInfo
  testsUpdated: number
  mocksRemoved: number
  testUtilities: string
  consolidationRatio: number
}

interface AdapterInfo {
  service: ExternalService
  path: string
  interface: string
  testFactory: string
}

interface TestUpdateResult {
  file: string
  success: boolean
  changes?: string[]
  error?: string
}
```

### 5. Migration Guide and Documentation

```typescript
// Generate migration guide for teams
class BoundaryAdapterMigrationGuide {
  generateMigrationGuide(consolidationResults: ConsolidationResult[]): string {
    return `
# External Service Mock Consolidation Migration Guide

## Overview
External service mocks have been consolidated into boundary adapters following the "mock at trust boundaries" principle. This provides better organization, consistency, and easier maintenance.

## Available Adapters

${consolidationResults.map((result) => this.generateAdapterDocumentation(result)).join('\n\n')}

## Migration Patterns

### Before: Scattered Mocks
\`\`\`typescript
// Multiple test files with similar mock setups
describe('UserService', () => {
  test('should send welcome email', async () => {
    const mockEmailService = {
      sendEmail: vi.fn().mockResolvedValue({ success: true, messageId: 'mock-id' })
    }
    vi.doMock('../services/email-service', () => mockEmailService)

    const userService = new UserService()
    await userService.createUser({ email: 'test@example.com' })

    expect(mockEmailService.sendEmail).toHaveBeenCalled()
  })
})
\`\`\`

### After: Boundary Adapter
\`\`\`typescript
// Centralized adapter usage
import { emailTestUtils } from '../../fixtures/adapters/email-test-utilities'

describe('UserService', () => {
  const emailAdapter = emailTestUtils.createSuccessAdapter()

  beforeEach(async () => {
    await emailAdapter.initialize()
  })

  afterEach(async () => {
    await emailAdapter.cleanup()
  })

  test('should send welcome email', async () => {
    const userService = new UserService({ emailAdapter })
    await userService.createUser({ email: 'test@example.com' })

    expect(emailAdapter.sendEmail).toHaveBeenCalledWith({
      to: 'test@example.com',
      subject: 'Welcome!',
      template: 'welcome'
    })
  })
})
\`\`\`

## Adapter Usage Patterns

### 1. Success Scenarios
\`\`\`typescript
const adapter = httpTestUtils.createSuccessAdapter()
\`\`\`

### 2. Error Scenarios
\`\`\`typescript
const adapter = httpTestUtils.createErrorAdapter('network')
\`\`\`

### 3. Custom Behavior
\`\`\`typescript
const adapter = httpTestUtils.createCustomAdapter({
  get: () => ({ data: 'custom response' }),
  post: vi.fn().mockRejectedValue(new Error('Custom error'))
})
\`\`\`

### 4. Workflow Scenarios
\`\`\`typescript
const adapter = httpTestUtils.createScenarioAdapter('user-registration-flow')
\`\`\`

## Benefits Achieved

1. **Centralized Mock Management**: All external service mocks in one place
2. **Consistent Behavior**: Standardized mock behaviors across tests
3. **Easier Maintenance**: Single source of truth for external service interfaces
4. **Better Testing**: More realistic external service simulation
5. **Reduced Duplication**: Eliminated ${this.calculateTotalMocksEliminated(consolidationResults)} duplicate mock setups

## Best Practices

### 1. Use Appropriate Test Utilities
- \`createSuccessAdapter()\` for happy path testing
- \`createErrorAdapter()\` for error handling testing
- \`createCustomAdapter()\` for specific scenarios
- \`createScenarioAdapter()\` for complex workflows

### 2. Proper Setup and Cleanup
\`\`\`typescript
beforeEach(async () => {
  await adapter.initialize()
})

afterEach(async () => {
  await adapter.cleanup()
})
\`\`\`

### 3. Realistic Test Data
Use the adapter's built-in test data generators:
\`\`\`typescript
const testData = adapter.generateTestData('user-scenario')
\`\`\`

### 4. Environment-Aware Configuration
\`\`\`typescript
const adapter = new EmailAdapter({
  testMode: process.env.NODE_ENV === 'test',
  provider: process.env.EMAIL_PROVIDER || 'test'
})
\`\`\`

## Migration Checklist

- [ ] Replace scattered mocks with boundary adapters
- [ ] Update test setup to use adapter utilities
- [ ] Add proper adapter initialization and cleanup
- [ ] Use realistic test scenarios from adapter utilities
- [ ] Update dependency injection to use adapters
- [ ] Remove obsolete mock setups
- [ ] Update team documentation and training materials

## Troubleshooting

### Common Issues

1. **Adapter Not Initialized**
   - Ensure \`await adapter.initialize()\` is called in \`beforeEach\`

2. **Mock Behavior Not Working**
   - Check that the correct test utility method is used
   - Verify adapter configuration is correct

3. **Test Isolation Issues**
   - Ensure \`await adapter.cleanup()\` is called in \`afterEach\`
   - Use fresh adapter instances for each test

4. **Performance Issues**
   - Use lightweight mock adapters for unit tests
   - Reserve real adapters for integration tests

## Support

For questions about adapter migration:
1. Check the adapter documentation in \`src/adapters/\`
2. Review test examples in \`__tests__/fixtures/adapters/\`
3. Consult the team's testing guidelines
4. Ask for help in the team chat
    `
  }

  private generateAdapterDocumentation(result: ConsolidationResult): string {
    return `### ${result.service.toUpperCase()} Adapter

**Location**: \`${result.adapterCreated.path}\`
**Test Utilities**: \`${result.testUtilities}\`
**Mocks Consolidated**: ${result.mocksRemoved}
**Tests Updated**: ${result.testsUpdated}

**Usage**:
\`\`\`typescript
import { ${result.service}TestUtils } from '../../fixtures/adapters/${result.service}-test-utilities'

const adapter = ${result.service}TestUtils.createSuccessAdapter()
\`\`\`

**Available Methods**:
- \`createSuccessAdapter()\` - For successful operations
- \`createErrorAdapter(type)\` - For error scenarios
- \`createCustomAdapter(behavior)\` - For custom behavior
- \`createScenarioAdapter(scenario)\` - For workflow testing
    `
  }

  private calculateTotalMocksEliminated(
    results: ConsolidationResult[],
  ): number {
    return results.reduce((total, result) => total + result.mocksRemoved, 0)
  }
}
```

## Acceptance Criteria

- [ ] External service mocks identified and categorized by service type
- [ ] Boundary adapters created for each major external service category
- [ ] Test adapter factories implemented with configurable behavior
- [ ] Mock consolidation engine successfully consolidates scattered mocks
- [ ] Tests updated to use boundary adapters instead of direct mocks
- [ ] Test utilities created for easy adapter configuration
- [ ] Adapter documentation and migration guide created
- [ ] At least 80% of external service mocks consolidated into adapters
- [ ] Performance impact assessed and optimized
- [ ] Team training materials updated with adapter patterns
- [ ] Monitoring system tracks adapter usage and effectiveness

## Benefits

1. **Centralized Management**: All external service mocks in standardized
   adapters
2. **Consistency**: Uniform behavior across all tests using external services
3. **Maintainability**: Single source of truth for external service interfaces
4. **Realistic Testing**: Better simulation of external service behavior
5. **Reduced Duplication**: Eliminated hundreds of duplicate mock setups

## Notes

- Focus on high-frequency external services first for maximum impact
- Ensure adapters are environment-aware (test vs production)
- Maintain backward compatibility during migration
- Monitor performance impact of adapter overhead
- Consider creating adapters for internal services that cross major boundaries
