---
name: Apply promotion rules - identify >2 mock tests for conversion
status: open
created: 2025-09-20T01:15:53Z
updated: 2025-09-20T01:15:53Z
github: [Will be updated when synced to GitHub]
depends_on: [011]
parallel: true
conflicts_with: []
---

# Task 015: Apply promotion rules - identify >2 mock tests for conversion

## Description

Identify and document all unit tests that use more than 2 mocks, as these are
candidates for promotion to integration tests. Tests with excessive mocking
often indicate that the unit being tested has too many dependencies or that the
test would be more valuable as an integration test.

This task establishes the foundation for Task 017 by creating a comprehensive
list of over-mocked tests and analyzing their conversion potential to
integration tests.

## Acceptance Criteria

1. **Mock Count Analysis**
   - [ ] Scan all test files and count mocks per test
   - [ ] Identify tests with >2 mocks across the codebase
   - [ ] Categorize by mock count (3-5, 6-10, 10+ mocks)
   - [ ] Document mock types and complexity for each flagged test

2. **Promotion Candidate Assessment**
   - [ ] Evaluate each >2 mock test for integration test conversion
   - [ ] Identify tests that would benefit from real implementations
   - [ ] Flag tests that mock too much internal logic
   - [ ] Assess integration test infrastructure requirements

3. **Risk and Impact Analysis**
   - [ ] Estimate effort required for each conversion
   - [ ] Identify dependencies that need real implementations
   - [ ] Assess test environment requirements
   - [ ] Document potential breaking changes

4. **Conversion Planning**
   - [ ] Prioritize tests by conversion value vs effort
   - [ ] Group related tests for batch conversion
   - [ ] Plan integration test structure and organization
   - [ ] Define success criteria for conversions

## Technical Details

### Mock Counting Strategy

1. **Automated Detection**

   ```typescript
   // Tool to count mocks per test
   interface MockAnalysis {
     testFile: string
     testName: string
     mockCount: number
     mockTypes: string[]
     complexity: 'low' | 'medium' | 'high'
     conversionCandidate: boolean
   }

   // Patterns to detect:
   const mockPatterns = [
     /vi\.mock\(/g,
     /jest\.mock\(/g,
     /\.mockImplementation\(/g,
     /\.mockResolvedValue\(/g,
     /\.mockReturnValue\(/g,
     /vi\.spyOn\(/g,
     /jest\.spyOn\(/g,
   ]
   ```

2. **Mock Classification**
   ```typescript
   enum MockType {
     EXTERNAL_SERVICE = 'external_service', // fetch, APIs
     INTERNAL_MODULE = 'internal_module', // own domain code
     UTILITY_FUNCTION = 'utility_function', // helpers, utils
     CONSOLE_OUTPUT = 'console_output', // logging
     FILE_SYSTEM = 'file_system', // fs operations
     DATABASE = 'database', // DB operations
     ENVIRONMENT = 'environment', // process.env, etc.
   }
   ```

### Promotion Rules Framework

1. **Automatic Promotion Candidates**
   - Tests with >5 mocks (high complexity)
   - Tests mocking >2 internal modules
   - Tests with deep mock chains
   - Tests mocking core business logic

2. **Manual Review Required**
   - Tests with 3-4 mocks
   - Tests mixing external and internal mocks
   - Tests with complex mock interactions
   - Tests in critical business flows

3. **No Promotion Needed**
   - Tests with 1-2 simple mocks
   - Tests mocking only external services
   - Tests with utility function mocks only
   - Pure unit tests with minimal dependencies

### Analysis Categories

1. **High-Value Conversion Candidates**

   ```typescript
   // Example: Authentication flow test
   describe('Authentication Service', () => {
     beforeEach(() => {
       vi.mock('../database/user-repository')
       vi.mock('../services/email-service')
       vi.mock('../services/token-service')
       vi.mock('../utils/crypto-utils')
       vi.mock('../config/auth-config')
     })

     // This test would benefit from integration testing
     // Real DB, real email service, real crypto
   })
   ```

2. **Complex Business Logic Tests**

   ```typescript
   // Example: Order processing
   describe('Order Processor', () => {
     // 8+ mocks for payment, inventory, shipping, etc.
     // Better as integration test with real services
   })
   ```

3. **Cross-Module Integration Tests**
   ```typescript
   // Example: File processing pipeline
   describe('File Processor', () => {
     // Mocks file reader, parser, validator, writer
     // Should test real file processing end-to-end
   })
   ```

### Conversion Impact Assessment

1. **Infrastructure Requirements**
   - Test database setup needs
   - External service test environments
   - File system test isolation
   - Network/API test configurations

2. **Performance Considerations**
   - Test execution time impact
   - Resource usage requirements
   - Parallel execution constraints
   - CI/CD pipeline effects

3. **Maintenance Benefits**
   - Reduced mock maintenance overhead
   - Better integration bug detection
   - Simplified test setup
   - Improved confidence in real scenarios

### Analysis Tools and Scripts

```bash
#!/bin/bash
# Mock counting script
find . -name "*.test.ts" -o -name "*.spec.ts" | while read file; do
  mock_count=$(grep -c -E "(vi\.mock|jest\.mock|mockImplementation|mockResolvedValue)" "$file")
  if [ "$mock_count" -gt 2 ]; then
    echo "$file: $mock_count mocks"
    # Extract test names and mock details
    grep -n -A 2 -B 2 "describe\|it\|test" "$file" | head -20
  fi
done
```

```typescript
// Analysis script for detailed mock inspection
interface TestAnalysis {
  file: string
  tests: Array<{
    name: string
    lineNumber: number
    mockCount: number
    mocks: MockDetail[]
  }>
}

interface MockDetail {
  type: MockType
  target: string
  complexity: number
  lineNumber: number
}
```

## Dependencies

- **Task 011**: Complete mock audit must be available to identify >2 mock
  patterns
- **No Conflicts**: Analysis task is safe for parallel execution

## Effort Estimate

**Size**: Large (3 days)

**Breakdown**:

- Day 1: Develop analysis tools and run initial mock counting
- Day 2: Detailed analysis of >2 mock tests and categorization
- Day 3: Assessment, prioritization, and conversion planning

**Skills Required**:

- Test analysis expertise
- Codebase architecture understanding
- Integration testing knowledge
- Project planning and prioritization

## Definition of Done

1. **Complete Mock Analysis**
   - Comprehensive list of all tests with >2 mocks
   - Detailed categorization by mock count and type
   - Assessment of conversion feasibility for each test
   - Risk and effort estimates for conversions

2. **Promotion Candidate List**
   - Prioritized list of integration test conversion candidates
   - Grouped conversions for efficient batch processing
   - Infrastructure requirements documented
   - Success criteria defined for each conversion

3. **Conversion Strategy**
   - Clear promotion rules for future test development
   - Guidelines for identifying over-mocked tests
   - Framework for integration test organization
   - Resource allocation plan for conversions

4. **Documentation and Reports**
   - Detailed analysis report with findings and recommendations
   - Conversion planning documents for Task 017
   - Tools and scripts for ongoing mock analysis
   - Team guidelines for avoiding over-mocking

5. **Baseline Metrics**
   - Current count of >2 mock tests
   - Mock complexity distribution
   - Estimated integration test suite size after conversion
   - Performance and resource impact projections

The analysis must provide sufficient detail and prioritization to enable
efficient execution of the integration test conversion work in Task 017,
ensuring maximum value from the promotion effort.
