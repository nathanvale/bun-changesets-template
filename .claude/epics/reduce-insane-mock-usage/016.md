---
epic: reduce-insane-mock-usage
task: 016
title: Replace internal module mocks with real implementations
size: XLarge
parallel: false
depends_on: [012, 013, 014]
status: pending
created: 2025-09-20T02:15:00Z
updated: 2025-09-20T02:15:00Z
---

# Task 016: Replace internal module mocks with real implementations

## Objective

Systematically replace all internal module mocks with real implementations,
eliminating one of the most problematic forms of mocking that prevents true
integration testing and hides real bugs.

## Background

Internal module mocking (mocking our own code) is particularly harmful as it
prevents testing real code paths, hides integration bugs, and creates false
confidence. This task represents the core of our mock reduction strategy -
replacing internal mocks with real implementations while maintaining test
isolation and performance.

## Requirements

### 1. Internal Mock Identification

Categorize internal mocks by type:

- **Domain logic mocks**: Business logic, services, repositories
- **Utility mocks**: Internal helper functions, formatters, validators
- **Infrastructure mocks**: File handling, configuration, logging
- **Cross-module mocks**: Module-to-module communication

### 2. Replacement Strategy

- **Direct replacement**: Remove mock and use real implementation
- **Dependency injection**: Modify code to support test vs production
  implementations
- **Test environment setup**: Create appropriate test infrastructure
- **Refactoring**: Modify code structure to support better testing

### 3. Integration Test Migration

Convert internal mock tests to proper integration tests:

- Move to appropriate test tier
- Set up real dependencies (database, file system, etc.)
- Maintain test isolation through proper cleanup
- Ensure performance remains acceptable

## Implementation Details

### 1. Internal Mock Analysis System

```typescript
// scripts/internal-mock-analyzer.ts

interface InternalMock {
  file: string
  line: number
  target: string
  mockType: 'vi.mock' | 'vi.spyOn' | 'doMock'
  category: InternalMockCategory
  complexity: MockComplexity
  dependencies: string[]
  replacementStrategy: ReplacementStrategy
  migrationTarget: 'unit' | 'integration' | 'e2e'
  blockers: string[]
}

enum InternalMockCategory {
  DOMAIN_LOGIC = 'domain-logic',
  UTILITIES = 'utilities',
  INFRASTRUCTURE = 'infrastructure',
  CROSS_MODULE = 'cross-module',
  CONFIGURATION = 'configuration',
}

enum MockComplexity {
  SIMPLE = 'simple', // Basic return values
  MODERATE = 'moderate', // Some logic in mock
  COMPLEX = 'complex', // Complex mock implementations
  IMPOSSIBLE = 'impossible', // Cannot be easily replaced
}

enum ReplacementStrategy {
  DIRECT = 'direct', // Remove mock, use real implementation
  INJECT = 'inject', // Add dependency injection
  REFACTOR = 'refactor', // Refactor code structure
  ENVIRONMENT = 'environment', // Set up test environment
  MANUAL = 'manual', // Requires manual intervention
}

class InternalMockAnalyzer {
  async analyzeInternalMocks(testDir: string): Promise<InternalMock[]> {
    const testFiles = await this.findTestFiles(testDir)
    const internalMocks: InternalMock[] = []

    for (const file of testFiles) {
      const content = await fs.readFile(file, 'utf-8')
      const fileMocks = this.findInternalMocks(file, content)
      internalMocks.push(...fileMocks)
    }

    return this.analyzeAndCategorize(internalMocks)
  }

  private findInternalMocks(file: string, content: string): InternalMock[] {
    const mocks: InternalMock[] = []
    const lines = content.split('\n')

    lines.forEach((line, index) => {
      // Find vi.mock calls with internal modules
      const mockMatch = line.match(/vi\.mock\(['"`]([^'"`]+)['"`]/)
      if (mockMatch && this.isInternalModule(mockMatch[1])) {
        mocks.push({
          file,
          line: index + 1,
          target: mockMatch[1],
          mockType: 'vi.mock',
          category: this.categorizeInternalModule(mockMatch[1]),
          complexity: MockComplexity.SIMPLE,
          dependencies: [],
          replacementStrategy: ReplacementStrategy.DIRECT,
          migrationTarget: 'integration',
          blockers: [],
        })
      }

      // Find vi.spyOn calls on internal modules
      const spyMatch = line.match(/vi\.spyOn\((\w+),\s*['"`](\w+)['"`]\)/)
      if (spyMatch && this.isInternalObject(spyMatch[1])) {
        mocks.push({
          file,
          line: index + 1,
          target: `${spyMatch[1]}.${spyMatch[2]}`,
          mockType: 'vi.spyOn',
          category: this.categorizeInternalFunction(spyMatch[1], spyMatch[2]),
          complexity: MockComplexity.SIMPLE,
          dependencies: [],
          replacementStrategy: ReplacementStrategy.DIRECT,
          migrationTarget: 'unit',
          blockers: [],
        })
      }
    })

    return mocks
  }

  private analyzeAndCategorize(mocks: InternalMock[]): InternalMock[] {
    return mocks.map((mock) => {
      // Analyze complexity
      mock.complexity = this.assessMockComplexity(mock)

      // Determine dependencies
      mock.dependencies = this.analyzeDependencies(mock)

      // Determine replacement strategy
      mock.replacementStrategy = this.determineReplacementStrategy(mock)

      // Determine migration target
      mock.migrationTarget = this.determineMigrationTarget(mock)

      // Identify blockers
      mock.blockers = this.identifyBlockers(mock)

      return mock
    })
  }

  private isInternalModule(target: string): boolean {
    return (
      target.startsWith('./') ||
      target.startsWith('../') ||
      target.includes('src/') ||
      target.includes('lib/') ||
      !target.includes('node_modules')
    )
  }

  private categorizeInternalModule(target: string): InternalMockCategory {
    if (
      target.includes('service') ||
      target.includes('repository') ||
      target.includes('domain')
    ) {
      return InternalMockCategory.DOMAIN_LOGIC
    }
    if (
      target.includes('util') ||
      target.includes('helper') ||
      target.includes('format')
    ) {
      return InternalMockCategory.UTILITIES
    }
    if (target.includes('config') || target.includes('env')) {
      return InternalMockCategory.CONFIGURATION
    }
    if (
      target.includes('file') ||
      target.includes('log') ||
      target.includes('infrastructure')
    ) {
      return InternalMockCategory.INFRASTRUCTURE
    }
    return InternalMockCategory.CROSS_MODULE
  }

  private determineReplacementStrategy(
    mock: InternalMock,
  ): ReplacementStrategy {
    switch (mock.category) {
      case InternalMockCategory.UTILITIES:
        return ReplacementStrategy.DIRECT
      case InternalMockCategory.DOMAIN_LOGIC:
        return mock.dependencies.length > 2
          ? ReplacementStrategy.INJECT
          : ReplacementStrategy.DIRECT
      case InternalMockCategory.INFRASTRUCTURE:
        return ReplacementStrategy.ENVIRONMENT
      case InternalMockCategory.CONFIGURATION:
        return ReplacementStrategy.INJECT
      default:
        return mock.complexity === MockComplexity.COMPLEX
          ? ReplacementStrategy.REFACTOR
          : ReplacementStrategy.DIRECT
    }
  }

  private determineMigrationTarget(
    mock: InternalMock,
  ): 'unit' | 'integration' | 'e2e' {
    if (
      mock.category === InternalMockCategory.UTILITIES &&
      mock.dependencies.length === 0
    ) {
      return 'unit'
    }
    if (
      mock.dependencies.length > 3 ||
      mock.category === InternalMockCategory.CROSS_MODULE
    ) {
      return 'e2e'
    }
    return 'integration'
  }

  private identifyBlockers(mock: InternalMock): string[] {
    const blockers: string[] = []

    if (mock.complexity === MockComplexity.IMPOSSIBLE) {
      blockers.push('Mock complexity too high for automated replacement')
    }

    if (mock.dependencies.some((dep) => this.isExternalDependency(dep))) {
      blockers.push('External dependencies require boundary adapters')
    }

    if (mock.target.includes('singleton') || mock.target.includes('global')) {
      blockers.push('Global state management required')
    }

    return blockers
  }
}
```

### 2. Direct Replacement Strategy

```typescript
// scripts/replacement-strategies/direct-replacement.ts

class DirectReplacementStrategy {
  async replace(mock: InternalMock): Promise<ReplacementResult> {
    const testContent = await fs.readFile(mock.file, 'utf-8')

    try {
      // Step 1: Remove the mock
      const withoutMock = this.removeMock(testContent, mock)

      // Step 2: Add real import if needed
      const withRealImport = this.addRealImport(withoutMock, mock)

      // Step 3: Replace mock usage with real implementation
      const withRealUsage = this.replaceUsageWithReal(withRealImport, mock)

      // Step 4: Add necessary test setup
      const finalContent = this.addTestSetup(withRealUsage, mock)

      return {
        success: true,
        newContent: finalContent,
        changes: [
          `Removed mock for ${mock.target}`,
          `Added real implementation usage`,
          `Updated test setup for real dependencies`,
        ],
      }
    } catch (error) {
      return {
        success: false,
        error: error.message,
        fallbackStrategy: 'inject',
      }
    }
  }

  private removeMock(content: string, mock: InternalMock): string {
    const lines = content.split('\n')

    if (mock.mockType === 'vi.mock') {
      // Remove vi.mock() call and its factory function
      const mockStart = this.findMockStart(lines, mock.line)
      const mockEnd = this.findMockEnd(lines, mockStart)

      if (mockStart !== -1 && mockEnd !== -1) {
        lines.splice(mockStart, mockEnd - mockStart + 1)
      }
    } else if (mock.mockType === 'vi.spyOn') {
      // Remove vi.spyOn setup
      lines.splice(mock.line - 1, 1)

      // Remove related mock implementations
      this.removeRelatedMockSetup(lines, mock)
    }

    return lines.join('\n')
  }

  private addRealImport(content: string, mock: InternalMock): string {
    const importTarget = this.resolveImportTarget(mock.target)
    const importStatement = this.generateImportStatement(importTarget)

    // Add import at the top of the file
    const lines = content.split('\n')
    const importIndex = this.findImportInsertionPoint(lines)

    lines.splice(importIndex, 0, importStatement)
    return lines.join('\n')
  }

  private replaceUsageWithReal(content: string, mock: InternalMock): string {
    let updatedContent = content

    // Replace mock object references with real implementations
    const mockVariableName = this.extractMockVariableName(mock)
    if (mockVariableName) {
      const realVariableName = mockVariableName
        .replace(/mock/i, '')
        .toLowerCase()
      const realImplementation = this.generateRealImplementation(
        mock,
        realVariableName,
      )

      updatedContent = updatedContent.replace(
        new RegExp(`const ${mockVariableName} = .*`, 'g'),
        realImplementation,
      )
    }

    return updatedContent
  }

  private generateRealImplementation(
    mock: InternalMock,
    variableName: string,
  ): string {
    switch (mock.category) {
      case InternalMockCategory.DOMAIN_LOGIC:
        return this.generateDomainLogicSetup(mock, variableName)
      case InternalMockCategory.UTILITIES:
        return this.generateUtilitySetup(mock, variableName)
      case InternalMockCategory.INFRASTRUCTURE:
        return this.generateInfrastructureSetup(mock, variableName)
      default:
        return `const ${variableName} = new ${this.extractClassName(mock.target)}()`
    }
  }

  private generateDomainLogicSetup(
    mock: InternalMock,
    variableName: string,
  ): string {
    const className = this.extractClassName(mock.target)
    const dependencies = this.analyzeDependencies(mock)

    if (dependencies.length === 0) {
      return `const ${variableName} = new ${className}()`
    }

    const dependencySetup = dependencies
      .map((dep) => {
        if (dep.includes('database') || dep.includes('repository')) {
          return 'const { db } = setupTestDatabase()'
        }
        if (dep.includes('file') || dep.includes('storage')) {
          return 'const fs = setupFileSystem()'
        }
        if (dep.includes('config')) {
          return 'const config = createTestConfig()'
        }
        return `const ${dep} = create${this.capitalize(dep)}()`
      })
      .join('\n    ')

    const constructorArgs = dependencies
      .map((dep) => {
        if (dep.includes('database')) return 'db'
        if (dep.includes('file')) return 'fs.tempDir.path'
        if (dep.includes('config')) return 'config'
        return dep
      })
      .join(', ')

    return `
    ${dependencySetup}
    const ${variableName} = new ${className}(${constructorArgs})
    `.trim()
  }

  private generateUtilitySetup(
    mock: InternalMock,
    variableName: string,
  ): string {
    // Utilities usually don't need special setup
    const utilityName = this.extractUtilityName(mock.target)
    return `import { ${utilityName} } from '${mock.target}'`
  }

  private generateInfrastructureSetup(
    mock: InternalMock,
    variableName: string,
  ): string {
    if (mock.target.includes('file')) {
      return `
    const fs = setupFileSystem()
    const ${variableName} = new FileService(fs.tempDir.path)
      `.trim()
    }

    if (mock.target.includes('log')) {
      return `const ${variableName} = createTestLogger()`
    }

    if (mock.target.includes('config')) {
      return `const ${variableName} = createTestConfig()`
    }

    return `const ${variableName} = create${this.capitalize(variableName)}()`
  }
}
```

### 3. Dependency Injection Strategy

```typescript
// scripts/replacement-strategies/injection-replacement.ts

class DependencyInjectionStrategy {
  async replace(mock: InternalMock): Promise<ReplacementResult> {
    // This strategy modifies the source code to support dependency injection
    const sourceFile = this.findSourceFile(mock.target)
    const testFile = mock.file

    try {
      // Step 1: Modify source code to accept dependencies
      const updatedSource = await this.addDependencyInjection(sourceFile, mock)

      // Step 2: Update test to use real dependencies
      const updatedTest = await this.updateTestForInjection(testFile, mock)

      // Step 3: Update other usages of the modified source
      await this.updateOtherUsages(sourceFile, mock)

      return {
        success: true,
        sourceChanges: updatedSource,
        testChanges: updatedTest,
        changes: [
          `Added dependency injection to ${sourceFile}`,
          `Updated test to use real dependencies`,
          `Updated other usages for new constructor signature`,
        ],
      }
    } catch (error) {
      return {
        success: false,
        error: error.message,
        fallbackStrategy: 'refactor',
      }
    }
  }

  private async addDependencyInjection(
    sourceFile: string,
    mock: InternalMock,
  ): Promise<string> {
    const content = await fs.readFile(sourceFile, 'utf-8')
    const dependencies = this.analyzeDependencies(mock)

    // Parse the class to add constructor dependency injection
    const ast = this.parseTypeScript(content)
    const classNode = this.findClassNode(ast, mock.target)

    if (!classNode) {
      throw new Error(`Could not find class for ${mock.target}`)
    }

    // Add constructor parameters for dependencies
    const updatedClass = this.addConstructorDependencies(
      classNode,
      dependencies,
    )

    // Replace hard-coded dependencies with injected ones
    const updatedMethods = this.replaceHardCodedDependencies(
      updatedClass,
      dependencies,
    )

    return this.generateUpdatedSource(ast, updatedMethods)
  }

  private addConstructorDependencies(
    classNode: any,
    dependencies: string[],
  ): any {
    const existingConstructor = this.findConstructor(classNode)

    if (existingConstructor) {
      // Add parameters to existing constructor
      return this.addParametersToConstructor(existingConstructor, dependencies)
    } else {
      // Create new constructor
      return this.createConstructorWithDependencies(classNode, dependencies)
    }
  }

  private replaceHardCodedDependencies(
    classNode: any,
    dependencies: string[],
  ): any {
    dependencies.forEach((dependency) => {
      // Replace `new DependencyClass()` with `this.dependency`
      const hardCodedUsage = this.findHardCodedUsage(classNode, dependency)
      if (hardCodedUsage) {
        this.replaceWithInjectedDependency(
          classNode,
          dependency,
          hardCodedUsage,
        )
      }
    })

    return classNode
  }

  private async updateTestForInjection(
    testFile: string,
    mock: InternalMock,
  ): Promise<string> {
    const content = await fs.readFile(testFile, 'utf-8')

    // Remove mock and add real dependency setup
    let updatedContent = this.removeMock(content, mock)

    // Add setup for real dependencies
    const dependencySetup = this.generateDependencySetup(mock)
    updatedContent = this.addDependencySetup(updatedContent, dependencySetup)

    // Update class instantiation to pass dependencies
    const constructorCall = this.generateConstructorCall(mock)
    updatedContent = this.updateConstructorCall(
      updatedContent,
      mock,
      constructorCall,
    )

    return updatedContent
  }

  private generateDependencySetup(mock: InternalMock): string {
    const dependencies = this.analyzeDependencies(mock)

    return dependencies
      .map((dep) => {
        if (dep.includes('database')) {
          return 'const { db } = setupTestDatabase()'
        }
        if (dep.includes('file')) {
          return 'const fs = setupFileSystem()'
        }
        if (dep.includes('email')) {
          return 'const emailService = createTestEmailService()'
        }
        if (dep.includes('config')) {
          return 'const config = createTestConfig()'
        }
        return `const ${dep} = create${this.capitalize(dep)}()`
      })
      .join('\n    ')
  }

  private generateConstructorCall(mock: InternalMock): string {
    const className = this.extractClassName(mock.target)
    const dependencies = this.analyzeDependencies(mock)

    const args = dependencies
      .map((dep) => {
        if (dep.includes('database')) return 'db'
        if (dep.includes('file')) return 'fs.tempDir.path'
        if (dep.includes('config')) return 'config'
        return dep
      })
      .join(', ')

    return `new ${className}(${args})`
  }
}
```

### 4. Test Environment Strategy

```typescript
// scripts/replacement-strategies/environment-replacement.ts

class EnvironmentReplacementStrategy {
  async replace(mock: InternalMock): Promise<ReplacementResult> {
    // Set up proper test environment to support real implementations
    const environmentSetup = this.determineRequiredEnvironment(mock)

    try {
      // Step 1: Create test environment setup
      await this.createEnvironmentSetup(environmentSetup, mock)

      // Step 2: Update test to use environment
      const updatedTest = await this.updateTestForEnvironment(
        mock.file,
        mock,
        environmentSetup,
      )

      // Step 3: Add cleanup mechanisms
      const withCleanup = this.addEnvironmentCleanup(
        updatedTest,
        environmentSetup,
      )

      return {
        success: true,
        newContent: withCleanup,
        environmentFiles: environmentSetup.files,
        changes: [
          `Created ${environmentSetup.type} environment setup`,
          `Updated test to use real ${mock.category} implementation`,
          `Added proper cleanup mechanisms`,
        ],
      }
    } catch (error) {
      return {
        success: false,
        error: error.message,
        fallbackStrategy: 'manual',
      }
    }
  }

  private determineRequiredEnvironment(mock: InternalMock): EnvironmentSetup {
    if (mock.target.includes('file') || mock.target.includes('fs')) {
      return {
        type: 'filesystem',
        setup: 'setupFileSystem',
        cleanup: 'cleanupFileSystem',
        files: ['__tests__/fixtures/utils/filesystem-setup.ts'],
      }
    }

    if (mock.target.includes('database') || mock.target.includes('db')) {
      return {
        type: 'database',
        setup: 'setupTestDatabase',
        cleanup: 'cleanupDatabase',
        files: ['__tests__/fixtures/utils/database-setup.ts'],
      }
    }

    if (mock.target.includes('config') || mock.target.includes('env')) {
      return {
        type: 'configuration',
        setup: 'setupTestConfig',
        cleanup: 'resetConfig',
        files: ['__tests__/fixtures/utils/config-setup.ts'],
      }
    }

    if (mock.target.includes('log')) {
      return {
        type: 'logging',
        setup: 'setupTestLogger',
        cleanup: 'resetLogger',
        files: ['__tests__/fixtures/utils/logger-setup.ts'],
      }
    }

    return {
      type: 'generic',
      setup: 'setupTestEnvironment',
      cleanup: 'cleanupTestEnvironment',
      files: [],
    }
  }

  private async createEnvironmentSetup(
    environment: EnvironmentSetup,
    mock: InternalMock,
  ): Promise<void> {
    const setupCode = this.generateEnvironmentSetupCode(environment, mock)

    for (const file of environment.files) {
      await fs.ensureFile(file)
      const existingContent = await fs.readFile(file, 'utf-8').catch(() => '')

      if (!existingContent.includes(environment.setup)) {
        await fs.writeFile(file, existingContent + '\n' + setupCode)
      }
    }
  }

  private generateEnvironmentSetupCode(
    environment: EnvironmentSetup,
    mock: InternalMock,
  ): string {
    switch (environment.type) {
      case 'filesystem':
        return this.generateFileSystemSetup(mock)
      case 'database':
        return this.generateDatabaseSetup(mock)
      case 'configuration':
        return this.generateConfigSetup(mock)
      case 'logging':
        return this.generateLoggerSetup(mock)
      default:
        return this.generateGenericSetup(mock)
    }
  }

  private generateFileSystemSetup(mock: InternalMock): string {
    return `
export function setupFileSystemFor${this.extractClassName(mock.target)}() {
  const fs = setupFileSystem()

  // Create any required directory structure
  const requiredDirs = ['temp', 'uploads', 'config']
  requiredDirs.forEach(dir => {
    fs.tempDir.createDir(dir)
  })

  // Create any required files
  fs.createTestFile('config.json', JSON.stringify({
    environment: 'test',
    uploads: fs.tempDir.path + '/uploads'
  }))

  return {
    tempDir: fs.tempDir,
    configPath: fs.tempDir.path + '/config.json',
    uploadsDir: fs.tempDir.path + '/uploads'
  }
}
    `
  }

  private generateDatabaseSetup(mock: InternalMock): string {
    return `
export function setupDatabaseFor${this.extractClassName(mock.target)}() {
  const { db } = setupTestDatabase()

  // Seed with any required test data
  db.seed({
    // Add seed data specific to ${mock.target}
  })

  return { db }
}
    `
  }

  private async updateTestForEnvironment(
    testFile: string,
    mock: InternalMock,
    environment: EnvironmentSetup,
  ): Promise<string> {
    const content = await fs.readFile(testFile, 'utf-8')

    // Remove mock
    let updatedContent = this.removeMock(content, mock)

    // Add environment setup import
    const importStatement = `import { ${environment.setup} } from '../fixtures/utils/${environment.type}-setup'`
    updatedContent = this.addImport(updatedContent, importStatement)

    // Add environment setup in test
    const setupCall = `const testEnv = ${environment.setup}()`
    updatedContent = this.addTestSetup(updatedContent, setupCall)

    // Replace mock usage with real implementation using environment
    updatedContent = this.replaceWithEnvironmentUsage(
      updatedContent,
      mock,
      environment,
    )

    return updatedContent
  }

  private replaceWithEnvironmentUsage(
    content: string,
    mock: InternalMock,
    environment: EnvironmentSetup,
  ): string {
    const className = this.extractClassName(mock.target)
    const mockVariable = this.extractMockVariableName(mock)

    if (mockVariable) {
      const realImplementation = this.generateRealImplementationWithEnvironment(
        className,
        environment,
      )

      return content.replace(
        new RegExp(`const ${mockVariable} = .*`, 'g'),
        `const ${mockVariable.replace(/mock/i, '').toLowerCase()} = ${realImplementation}`,
      )
    }

    return content
  }

  private generateRealImplementationWithEnvironment(
    className: string,
    environment: EnvironmentSetup,
  ): string {
    switch (environment.type) {
      case 'filesystem':
        return `new ${className}(testEnv.tempDir.path)`
      case 'database':
        return `new ${className}(testEnv.db)`
      case 'configuration':
        return `new ${className}(testEnv.config)`
      case 'logging':
        return `new ${className}(testEnv.logger)`
      default:
        return `new ${className}(testEnv)`
    }
  }
}

interface EnvironmentSetup {
  type: string
  setup: string
  cleanup: string
  files: string[]
}
```

### 5. Progress Tracking and Metrics

```typescript
// Track progress and generate reports
class InternalMockReplacementTracker {
  async trackProgress(
    initialMocks: InternalMock[],
    replacementResults: ReplacementResult[],
  ): Promise<ProgressReport> {
    const successful = replacementResults.filter((r) => r.success)
    const failed = replacementResults.filter((r) => !r.success)

    const mockReduction = successful.reduce((total, result) => {
      return total + (result.mocksEliminated || 1)
    }, 0)

    const migrationStats = this.calculateMigrationStats(successful)

    return {
      totalInternalMocks: initialMocks.length,
      mocksReplaced: successful.length,
      mocksFailed: failed.length,
      mockReduction,
      migrationStats,
      strategiesUsed: this.countStrategiesUsed(successful),
      blockers: this.consolidateBlockers(failed),
      performanceImpact: await this.assessPerformanceImpact(successful),
    }
  }

  private calculateMigrationStats(
    results: ReplacementResult[],
  ): MigrationStats {
    return {
      unitToIntegration: results.filter(
        (r) => r.migrationTarget === 'integration',
      ).length,
      unitToE2E: results.filter((r) => r.migrationTarget === 'e2e').length,
      remainingUnit: results.filter((r) => r.migrationTarget === 'unit').length,
    }
  }

  generateProgressReport(progress: ProgressReport): string {
    return `
# Internal Mock Replacement Progress Report

## Overall Progress
- **Total Internal Mocks**: ${progress.totalInternalMocks}
- **Successfully Replaced**: ${progress.mocksReplaced}
- **Failed Replacements**: ${progress.mocksFailed}
- **Total Mock Reduction**: ${progress.mockReduction}
- **Success Rate**: ${((progress.mocksReplaced / progress.totalInternalMocks) * 100).toFixed(1)}%

## Migration Statistics
- **Unit → Integration**: ${progress.migrationStats.unitToIntegration}
- **Unit → E2E**: ${progress.migrationStats.unitToE2E}
- **Remaining Unit**: ${progress.migrationStats.remainingUnit}

## Strategies Used
${Object.entries(progress.strategiesUsed)
  .map(([strategy, count]) => `- **${strategy}**: ${count} replacements`)
  .join('\n')}

## Performance Impact
- **Test Execution Time Change**: ${progress.performanceImpact.executionTimeChange}
- **Memory Usage Change**: ${progress.performanceImpact.memoryChange}
- **Test Reliability Improvement**: ${progress.performanceImpact.reliabilityImprovement}

## Remaining Blockers
${progress.blockers.map((blocker) => `- ${blocker}`).join('\n')}

## Benefits Achieved
1. **Realistic Testing**: ${progress.mocksReplaced} tests now use real implementations
2. **Bug Detection**: Integration tests can now catch real bugs
3. **Maintenance Reduction**: Eliminated ${progress.mockReduction} mock setups
4. **Code Confidence**: Tests now validate actual code paths
    `
  }
}

interface ProgressReport {
  totalInternalMocks: number
  mocksReplaced: number
  mocksFailed: number
  mockReduction: number
  migrationStats: MigrationStats
  strategiesUsed: Record<string, number>
  blockers: string[]
  performanceImpact: PerformanceImpact
}

interface MigrationStats {
  unitToIntegration: number
  unitToE2E: number
  remainingUnit: number
}

interface PerformanceImpact {
  executionTimeChange: string
  memoryChange: string
  reliabilityImprovement: string
}
```

## Acceptance Criteria

- [ ] All internal module mocks identified and categorized by type
- [ ] Replacement strategies determined for each mock
      (direct/inject/environment/refactor)
- [ ] Direct replacement strategy successfully eliminates simple internal mocks
- [ ] Dependency injection strategy adds DI to classes requiring it
- [ ] Environment replacement strategy creates proper test environments
- [ ] Source code modifications made where necessary for better testability
- [ ] Tests migrated to appropriate test tiers (unit/integration/e2e)
- [ ] Real implementations replace mocked internal modules
- [ ] Test environments properly set up for infrastructure dependencies
- [ ] Performance impact assessed and optimized
- [ ] At least 80% of internal mocks successfully replaced
- [ ] Progress tracking and reporting system implemented
- [ ] Documentation updated with new testing patterns

## Benefits

1. **Realistic Testing**: Tests now use actual internal implementations
2. **Bug Detection**: Integration tests catch real interaction bugs
3. **Code Confidence**: Validates actual code paths and logic
4. **Maintenance Reduction**: Eliminates complex internal mock setups
5. **Refactoring Safety**: Real implementations provide better refactoring
   confidence

## Notes

- This is the most complex task requiring careful analysis of each mock
- Some source code modifications may be necessary for better testability
- Performance monitoring is crucial as integration tests may be slower
- Consider breaking this into smaller subtasks for different mock categories
- Coordinate with team to ensure understanding of new patterns
