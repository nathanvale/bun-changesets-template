---
name: Replace internal module mocks with real implementations
status: open
created: 2025-09-20T01:15:53Z
updated: 2025-09-20T01:15:53Z
github: [Will be updated when synced to GitHub]
depends_on: [001, 002, 015]
parallel: false
conflicts_with: []
---

# Task 016: Replace internal module mocks with real implementations

## Description

Replace mocks of internal domain modules with real implementations to improve test reliability and catch genuine integration issues. This task focuses on eliminating mocks of our own code in favor of testing actual module interactions.

Internal module mocking often indicates poor module boundaries or over-complex dependencies. By using real implementations, we improve test confidence and identify actual design issues in our codebase.

## Acceptance Criteria

1. **Internal Mock Identification**
   - [ ] Identify all mocks of internal domain modules
   - [ ] Categorize by module type (services, repositories, utilities, etc.)
   - [ ] Assess dependency complexity for each mocked module
   - [ ] Document current mock usage patterns

2. **Real Implementation Integration**
   - [ ] Replace internal service mocks with real implementations
   - [ ] Remove mocks of internal repository modules
   - [ ] Eliminate business logic mocks
   - [ ] Maintain test isolation where necessary

3. **Dependency Management**
   - [ ] Resolve circular dependencies exposed by real implementations
   - [ ] Implement proper dependency injection patterns
   - [ ] Create test-specific configurations for dependencies
   - [ ] Ensure proper resource cleanup in tests

4. **Test Quality Improvement**
   - [ ] Maintain or improve test coverage
   - [ ] Catch real integration bugs previously hidden by mocks
   - [ ] Improve test reliability and confidence
   - [ ] Simplify test setup and maintenance

## Technical Details

### Internal Mock Categories

1. **Service Layer Mocks**
   ```typescript
   // BEFORE - Mocking internal services
   vi.mock('../services/user-service', () => ({
     UserService: {
       createUser: vi.fn().mockResolvedValue({ id: 1 }),
       updateUser: vi.fn().mockResolvedValue({ id: 1 }),
       deleteUser: vi.fn().mockResolvedValue(true)
     }
   }));
   
   // AFTER - Use real service with test dependencies
   import { UserService } from '../services/user-service';
   import { createTestDatabase } from '../test/helpers/database';
   
   describe('User Management', () => {
     let userService: UserService;
     let testDb: TestDatabase;
   
     beforeEach(async () => {
       testDb = await createTestDatabase();
       userService = new UserService(testDb);
     });
   });
   ```

2. **Repository Layer Mocks**
   ```typescript
   // BEFORE - Mocking repositories
   vi.mock('../repositories/user-repository', () => ({
     findById: vi.fn().mockResolvedValue(mockUser),
     save: vi.fn().mockResolvedValue(mockUser),
     delete: vi.fn().mockResolvedValue(true)
   }));
   
   // AFTER - Use real repository with test database
   import { UserRepository } from '../repositories/user-repository';
   import { createTestDatabase } from '../test/helpers/database';
   
   describe('User Repository', () => {
     let repository: UserRepository;
     let testDb: TestDatabase;
   
     beforeEach(async () => {
       testDb = await createTestDatabase();
       repository = new UserRepository(testDb.connection);
     });
   });
   ```

3. **Business Logic Mocks**
   ```typescript
   // BEFORE - Mocking business logic
   vi.mock('../domain/order-processor', () => ({
     processOrder: vi.fn().mockResolvedValue({ status: 'processed' }),
     calculateTotal: vi.fn().mockReturnValue(100),
     validateOrder: vi.fn().mockReturnValue(true)
   }));
   
   // AFTER - Use real business logic with test data
   import { OrderProcessor } from '../domain/order-processor';
   import { createTestOrder } from '../test/fixtures/orders';
   
   describe('Order Processing', () => {
     let processor: OrderProcessor;
   
     beforeEach(() => {
       processor = new OrderProcessor({
         paymentService: createTestPaymentService(),
         inventoryService: createTestInventoryService()
       });
     });
   });
   ```

### Replacement Strategies

1. **Dependency Injection Patterns**
   ```typescript
   // Enable real implementation testing
   export class UserService {
     constructor(
       private repository: UserRepository,
       private emailService: EmailService,
       private logger: Logger
     ) {}
   }
   
   // Test with real internal dependencies, mock external only
   const userService = new UserService(
     new UserRepository(testDb),    // Real internal
     mockEmailService,              // Mock external
     testLogger                     // Test logger
   );
   ```

2. **Test Factory Patterns**
   ```typescript
   // Create real implementations with test configurations
   export function createTestUserService(overrides = {}) {
     return new UserService(
       overrides.repository || new UserRepository(getTestDb()),
       overrides.emailService || createMockEmailService(),
       overrides.logger || createTestLogger()
     );
   }
   ```

3. **Configuration-Based Testing**
   ```typescript
   // Use different configurations for testing
   const testConfig = {
     database: {
       type: 'sqlite',
       database: ':memory:',
       synchronize: true
     },
     email: {
       provider: 'test',
       sendEmails: false
     }
   };
   ```

### Implementation Phases

1. **Phase 1: Low-Risk Modules**
   - Pure business logic with minimal dependencies
   - Utility modules with clear interfaces
   - Modules without external service dependencies

2. **Phase 2: Service Layer**
   - Application services with repository dependencies
   - Domain services with clear boundaries
   - Modules with well-defined interfaces

3. **Phase 3: Complex Integrations**
   - Modules with multiple internal dependencies
   - Cross-domain interactions
   - Modules with complex initialization

### Dependency Resolution

1. **Circular Dependency Detection**
   ```bash
   # Tool to detect circular dependencies
   npx madge --circular --extensions ts src/
   ```

2. **Dependency Injection Setup**
   ```typescript
   // Test container for dependency injection
   export class TestContainer {
     private instances = new Map();
   
     register<T>(token: string, factory: () => T): void {
       this.instances.set(token, factory);
     }
   
     resolve<T>(token: string): T {
       const factory = this.instances.get(token);
       return factory ? factory() : null;
     }
   }
   ```

3. **Test Environment Isolation**
   ```typescript
   // Ensure test isolation
   afterEach(async () => {
     await cleanupTestDatabase();
     await clearTestCache();
     resetTestSingletons();
   });
   ```

### Risk Mitigation

1. **Performance Impact**
   - Monitor test execution times
   - Optimize slow real implementations
   - Use test-specific optimizations

2. **Test Reliability**
   - Ensure deterministic test data
   - Handle async operations properly
   - Manage test state isolation

3. **Resource Management**
   - Proper cleanup of real resources
   - Memory leak prevention
   - Database connection management

## Dependencies

- **Task 001**: Improved test infrastructure needed for real implementations
- **Task 002**: Environment management required for test configurations
- **Task 015**: Must know which tests have excessive internal mocking
- **Sequential Execution**: Must be done sequentially due to extensive file modifications

## Effort Estimate

**Size**: XLarge (5 days)

**Breakdown**:
- Day 1: Internal mock audit and dependency analysis
- Day 2: Implement test infrastructure for real implementations
- Day 3: Replace service and repository mocks
- Day 4: Replace business logic mocks
- Day 5: Validation, optimization, and cleanup

**Skills Required**:
- Deep understanding of application architecture
- Dependency injection expertise
- Test infrastructure development
- Performance optimization skills

## Definition of Done

1. **Mock Elimination**
   - All internal service, repository, and business logic mocks removed
   - Real implementations used in place of mocks
   - Test coverage maintained or improved
   - No regression in test functionality

2. **Improved Architecture**
   - Better dependency injection patterns
   - Clearer module boundaries
   - Reduced circular dependencies
   - More testable code structure

3. **Enhanced Test Quality**
   - Tests catch real integration issues
   - Improved confidence in module interactions
   - Better error detection and reporting
   - Simplified test maintenance

4. **Infrastructure Improvements**
   - Robust test dependency injection system
   - Efficient test database management
   - Proper test isolation mechanisms
   - Resource cleanup automation

5. **Performance and Reliability**
   - Acceptable test performance with real implementations
   - Reliable test execution in all environments
   - Proper resource management
   - No memory leaks or resource contention

The implementation must demonstrate that internal modules can be effectively tested without mocking, revealing and fixing real architectural issues while improving overall code quality and test confidence.