---
name: Remove utility function mocking (path, string utils)
status: open
created: 2025-09-20T01:15:53Z
updated: 2025-09-20T01:15:53Z
github: [Will be updated when synced to GitHub]
depends_on: [011]
parallel: true
conflicts_with: []
---

# Task 013: Remove utility function mocking (path, string utils)

## Description

Eliminate mocking of internal utility functions such as path manipulation,
string processing, and other pure helper functions. These utilities should be
tested with their real implementations rather than mocked, as mocking them often
defeats the purpose of testing and can hide real bugs.

This task focuses on removing unnecessary mocks of deterministic utility
functions and replacing them with actual function calls, improving test
reliability and catching real integration issues.

## Acceptance Criteria

1. **Utility Mock Elimination**
   - [ ] Remove all mocks of internal path utility functions
   - [ ] Eliminate string processing utility mocks
   - [ ] Remove mocks of pure helper functions (formatters, validators, etc.)
   - [ ] Maintain test coverage while using real implementations

2. **Real Implementation Usage**
   - [ ] Replace mocked utilities with actual function calls
   - [ ] Ensure test environments support real utility execution
   - [ ] Handle any file system or environment dependencies properly
   - [ ] Validate that real utilities work as expected in tests

3. **Test Improvement**
   - [ ] Improve test reliability by testing actual behavior
   - [ ] Catch real bugs that mocks would hide
   - [ ] Simplify test setup by removing unnecessary mocking
   - [ ] Enhance test readability with straightforward assertions

4. **Documentation**
   - [ ] Document which utilities should never be mocked
   - [ ] Provide guidelines for distinguishing mockable vs non-mockable
         utilities
   - [ ] Create examples of proper utility testing
   - [ ] Update team testing standards

## Technical Details

### Utility Categories to Address

1. **Path Utilities**

   ```typescript
   // BEFORE - Unnecessary mocking
   vi.mock('path', () => ({
     join: vi.fn().mockReturnValue('/mocked/path'),
     resolve: vi.fn().mockReturnValue('/resolved/path'),
     dirname: vi.fn().mockReturnValue('/parent'),
   }))

   // AFTER - Use real path utilities
   import path from 'path'
   const result = path.join('src', 'utils', 'file.ts')
   expect(result).toBe('src/utils/file.ts')
   ```

2. **String Processing Utilities**

   ```typescript
   // BEFORE - Mocking string utilities
   vi.mock('../utils/string-utils', () => ({
     capitalize: vi.fn().mockReturnValue('Mocked'),
     slugify: vi.fn().mockReturnValue('mocked-slug'),
   }))

   // AFTER - Test real string processing
   import { capitalize, slugify } from '../utils/string-utils'
   expect(capitalize('hello')).toBe('Hello')
   expect(slugify('Hello World!')).toBe('hello-world')
   ```

3. **Validation Utilities**

   ```typescript
   // BEFORE - Mocking validators
   vi.mock('../utils/validators', () => ({
     isEmail: vi.fn().mockReturnValue(true),
     isValidUrl: vi.fn().mockReturnValue(false),
   }))

   // AFTER - Test real validation logic
   import { isEmail, isValidUrl } from '../utils/validators'
   expect(isEmail('test@example.com')).toBe(true)
   expect(isValidUrl('invalid-url')).toBe(false)
   ```

4. **Formatting Utilities**

   ```typescript
   // BEFORE - Mocking formatters
   vi.mock('../utils/formatters', () => ({
     formatDate: vi.fn().mockReturnValue('mocked-date'),
     formatCurrency: vi.fn().mockReturnValue('$0.00'),
   }))

   // AFTER - Test real formatting
   import { formatDate, formatCurrency } from '../utils/formatters'
   expect(formatDate(new Date('2023-01-01'))).toBe('2023-01-01')
   expect(formatCurrency(1234.56)).toBe('$1,234.56')
   ```

### Implementation Strategy

1. **Identify Pure Utilities**
   - Functions with no side effects
   - Deterministic functions (same input = same output)
   - Utilities that don't depend on external services
   - Helper functions that should be tested directly

2. **Handle Environment Dependencies**

   ```typescript
   // For utilities that need specific environments
   beforeEach(() => {
     // Set up test environment if needed
     process.env.NODE_ENV = 'test'
   })

   // Use temporary directories for file operations
   import { tmpdir } from 'os'
   import { mkdtemp } from 'fs/promises'

   let tempDir: string
   beforeEach(async () => {
     tempDir = await mkdtemp(path.join(tmpdir(), 'test-'))
   })
   ```

3. **Replace Mock Patterns**
   - Remove `vi.mock()` calls for utility modules
   - Replace `mockReturnValue()` with real function calls
   - Remove `mockImplementation()` for pure functions
   - Update assertions to test real behavior

4. **Validate Real Behavior**
   - Ensure utilities work correctly in test environment
   - Add edge case testing that mocks might have hidden
   - Verify error handling with real implementations
   - Test boundary conditions properly

### Risk Mitigation

1. **Performance Considerations**
   - Monitor test execution time changes
   - Optimize slow real utilities if needed
   - Use test-specific configurations for heavy operations

2. **Environment Isolation**
   - Ensure tests don't affect global state
   - Use temporary resources for file operations
   - Clean up after tests properly

3. **Error Handling**
   - Test real error conditions
   - Ensure utilities handle edge cases correctly
   - Validate error messages and types

## Dependencies

- **Task 011**: Mock audit must identify which utilities are being mocked
- **No Conflicts**: Utility function changes are isolated and safe for parallel
  execution

## Effort Estimate

**Size**: Medium (2 days)

**Breakdown**:

- Day 1: Identify and categorize utility mocks, plan replacements
- Day 2: Implement replacements and validate behavior

**Skills Required**:

- Understanding of pure vs impure functions
- Test refactoring expertise
- Utility function knowledge
- Environment setup skills

## Definition of Done

1. **Mock Elimination**
   - All internal utility function mocks removed
   - Path, string, validation, and formatting utility mocks eliminated
   - Test coverage maintained or improved
   - No regression in test functionality

2. **Real Implementation Testing**
   - All utility tests use real implementations
   - Edge cases and error conditions properly tested
   - Environment dependencies handled correctly
   - Test isolation maintained

3. **Improved Test Quality**
   - Tests catch real bugs that mocks would hide
   - Simplified test setup without unnecessary mocking
   - Better integration testing of utility combinations
   - Enhanced confidence in utility reliability

4. **Documentation and Guidelines**
   - List of utilities that should never be mocked
   - Guidelines for identifying pure vs impure functions
   - Examples of proper utility testing patterns
   - Team standards for utility testing

5. **Performance and Reliability**
   - No significant test performance degradation
   - Improved test reliability with real implementations
   - Better error reporting from real utility failures
   - Reduced test maintenance overhead

The implementation must demonstrate that internal utilities can be reliably
tested without mocking, establishing patterns for testing pure functions
throughout the codebase.
