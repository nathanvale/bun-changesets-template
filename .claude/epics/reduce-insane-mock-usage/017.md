---
name: Convert over-mocked unit tests to integration tests
status: open
created: 2025-09-20T01:15:53Z
updated: 2025-09-20T01:15:53Z
github: [Will be updated when synced to GitHub]
depends_on: [015, 016]
parallel: false
conflicts_with: []
---

# Task 017: Convert over-mocked unit tests to integration tests

## Description

Convert unit tests with excessive mocking (>2 mocks, identified in Task 015)
into proper integration tests. These tests will use real implementations and
test actual system behavior rather than mocked interactions, providing higher
confidence and catching real integration issues.

This task represents a fundamental shift from testing isolated units with heavy
mocking to testing integrated behavior with minimal, targeted mocking of
external boundaries only.

## Acceptance Criteria

1. **Test Conversion Execution**
   - [ ] Convert all prioritized >2 mock tests to integration tests
   - [ ] Organize integration tests in appropriate test structure
   - [ ] Implement proper test data management
   - [ ] Ensure comprehensive integration test coverage

2. **Integration Test Infrastructure**
   - [ ] Set up integration test environment
   - [ ] Implement test database management
   - [ ] Create shared test fixtures and utilities
   - [ ] Establish integration test execution pipeline

3. **Test Quality Improvement**
   - [ ] Achieve better system behavior coverage
   - [ ] Catch real integration bugs
   - [ ] Improve test reliability and maintainability
   - [ ] Reduce overall test complexity

4. **Performance and Reliability**
   - [ ] Ensure acceptable integration test performance
   - [ ] Implement proper test isolation
   - [ ] Handle test data consistency
   - [ ] Manage resource usage effectively

## Technical Details

### Conversion Strategy

1. **Test Classification and Prioritization**

   ```typescript
   // High Priority: Business Critical Flows
   describe('Order Processing Integration', () => {
     // BEFORE: 8+ mocks (payment, inventory, shipping, etc.)
     // AFTER: Real services with test database

     let orderService: OrderService
     let testDb: TestDatabase
     let testPaymentGateway: TestPaymentGateway

     beforeEach(async () => {
       testDb = await createTestDatabase()
       testPaymentGateway = new TestPaymentGateway()
       orderService = new OrderService({
         database: testDb,
         paymentGateway: testPaymentGateway, // Still mock external
         emailService: new TestEmailService(), // Test implementation
       })
     })

     it('processes complete order flow', async () => {
       // Test real order processing with minimal external mocks
       const order = await orderService.processOrder(testOrderData)
       expect(order.status).toBe('completed')
       expect(testPaymentGateway.charges).toHaveLength(1)
     })
   })
   ```

2. **Integration Test Organization**

   ```
   tests/
   ├── unit/                 # Simple unit tests (0-2 mocks)
   │   ├── utils/
   │   ├── models/
   │   └── validators/
   ├── integration/          # Multi-component tests
   │   ├── services/
   │   ├── workflows/
   │   └── api/
   └── e2e/                  # Full system tests
       ├── user-flows/
       └── api-endpoints/
   ```

3. **Mock Boundary Management**

   ```typescript
   // Clear boundaries: Mock only external services
   interface TestBoundaries {
     // MOCK: External services
     paymentGateway: MockPaymentGateway
     emailProvider: MockEmailProvider
     fileStorage: MockFileStorage

     // REAL: Internal implementations
     userService: UserService
     orderService: OrderService
     inventoryService: InventoryService
     database: TestDatabase
   }
   ```

### Conversion Patterns

1. **Service Integration Tests**

   ```typescript
   // BEFORE: Heavy mocking
   describe('UserService', () => {
     beforeEach(() => {
       vi.mock('../repositories/user-repository')
       vi.mock('../services/email-service')
       vi.mock('../services/audit-service')
       vi.mock('../utils/validation')
       vi.mock('../config/settings')
     })
   })

   // AFTER: Integration test
   describe('User Management Integration', () => {
     let userService: UserService
     let testDb: TestDatabase
     let mockEmailService: MockEmailService

     beforeEach(async () => {
       testDb = await createTestDatabase()
       mockEmailService = new MockEmailService()

       userService = new UserService({
         repository: new UserRepository(testDb.connection),
         emailService: mockEmailService,
         auditService: new AuditService(testDb.connection),
         validator: new UserValidator(),
         settings: testSettings,
       })
     })

     it('creates user with complete workflow', async () => {
       const userData = createTestUserData()
       const user = await userService.createUser(userData)

       // Verify real database state
       const savedUser = await testDb.findUser(user.id)
       expect(savedUser).toMatchObject(userData)

       // Verify audit trail
       const auditLogs = await testDb.findAuditLogs(user.id)
       expect(auditLogs).toHaveLength(1)

       // Verify external service call
       expect(mockEmailService.sentEmails).toHaveLength(1)
     })
   })
   ```

2. **Workflow Integration Tests**

   ```typescript
   // Complex business workflows with multiple components
   describe('E-commerce Checkout Integration', () => {
     let checkoutWorkflow: CheckoutWorkflow
     let testSystem: TestSystemBuilder

     beforeEach(async () => {
       testSystem = await TestSystemBuilder.create()
         .withDatabase()
         .withPaymentGateway()
         .withInventorySystem()
         .withEmailService()
         .build()

       checkoutWorkflow = testSystem.getCheckoutWorkflow()
     })

     it('completes full checkout process', async () => {
       // Test complete workflow with real components
       const cart = await testSystem.createTestCart()
       const payment = testSystem.createTestPayment()

       const result = await checkoutWorkflow.process(cart, payment)

       expect(result.order.status).toBe('confirmed')
       expect(result.payment.status).toBe('completed')
       expect(result.inventory.updated).toBe(true)
       expect(testSystem.emailService.confirmationsSent).toBe(1)
     })
   })
   ```

### Test Infrastructure Requirements

1. **Database Management**

   ```typescript
   export class TestDatabase {
     private connection: DatabaseConnection

     async setup(): Promise<void> {
       this.connection = await createTestConnection()
       await this.runMigrations()
       await this.seedTestData()
     }

     async cleanup(): Promise<void> {
       await this.clearAllTables()
       await this.connection.close()
     }

     async transaction<T>(fn: () => Promise<T>): Promise<T> {
       return this.connection.transaction(fn)
     }
   }
   ```

2. **Test System Builder**

   ```typescript
   export class TestSystemBuilder {
     private components = new Map()

     withDatabase(): TestSystemBuilder {
       this.components.set('database', () => new TestDatabase())
       return this
     }

     withEmailService(): TestSystemBuilder {
       this.components.set('emailService', () => new MockEmailService())
       return this
     }

     async build(): Promise<TestSystem> {
       const system = new TestSystem()
       for (const [name, factory] of this.components) {
         system.register(name, await factory())
       }
       return system
     }
   }
   ```

3. **Test Data Management**

   ```typescript
   export class TestDataManager {
     async createUser(overrides = {}): Promise<User> {
       return this.database.create('users', {
         ...defaultUserData,
         ...overrides,
       })
     }

     async createOrder(userId: string, overrides = {}): Promise<Order> {
       return this.database.create('orders', {
         userId,
         ...defaultOrderData,
         ...overrides,
       })
     }

     async cleanup(): Promise<void> {
       await this.database.clearTestData()
     }
   }
   ```

### Performance Optimization

1. **Test Parallelization**

   ```typescript
   // Isolate test data for parallel execution
   describe.concurrent('User Service Integration', () => {
     it('creates user', async () => {
       const testId = generateTestId()
       const testDb = await createIsolatedTestDb(testId)
       // Test with isolated data
     })
   })
   ```

2. **Resource Pooling**

   ```typescript
   // Shared test resources
   export class TestResourcePool {
     private databases: TestDatabase[] = []
     private emailServices: MockEmailService[] = []

     async acquire<T>(type: string): Promise<T> {
       return this.getFromPool(type) || this.create(type)
     }

     async release<T>(resource: T): Promise<void> {
       await this.cleanup(resource)
       this.returnToPool(resource)
     }
   }
   ```

### Migration Process

1. **Batch Conversion Strategy**
   - Group related tests for simultaneous conversion
   - Convert by feature area to maintain coherence
   - Prioritize high-value, low-risk conversions first

2. **Validation Process**
   - Ensure no functionality regression
   - Verify improved error detection
   - Validate performance acceptability
   - Confirm test reliability

## Dependencies

- **Task 015**: Must have identified >2 mock tests for conversion
- **Task 016**: Internal mocks must be replaced first
- **Sequential Execution**: Major restructuring requires sequential execution

## Effort Estimate

**Size**: XLarge (5 days)

**Breakdown**:

- Day 1: Set up integration test infrastructure
- Day 2: Convert high-priority business workflow tests
- Day 3: Convert service layer integration tests
- Day 4: Convert remaining over-mocked tests
- Day 5: Optimization, validation, and documentation

**Skills Required**:

- Integration testing expertise
- Test infrastructure architecture
- Database and transaction management
- Performance optimization
- System design understanding

## Definition of Done

1. **Complete Test Conversion**
   - All identified >2 mock tests converted to integration tests
   - Proper integration test organization and structure
   - Comprehensive test coverage maintained
   - No functionality regression

2. **Robust Integration Test Infrastructure**
   - Efficient test database management
   - Reliable test data fixtures
   - Proper test isolation mechanisms
   - Resource cleanup automation

3. **Improved Test Quality**
   - Tests catch real integration bugs
   - Better system behavior coverage
   - Reduced test maintenance complexity
   - Enhanced confidence in system reliability

4. **Performance and Scalability**
   - Acceptable integration test execution times
   - Efficient resource utilization
   - Parallel test execution capability
   - Scalable test infrastructure

5. **Documentation and Standards**
   - Integration testing guidelines
   - Test infrastructure usage documentation
   - Best practices for future integration tests
   - Migration lessons learned

The implementation must demonstrate that complex, over-mocked unit tests can be
successfully converted to reliable integration tests that provide superior
coverage and confidence while maintaining good performance and maintainability.
