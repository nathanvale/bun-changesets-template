---
epic: reduce-insane-mock-usage
task: 017
title: Convert over-mocked unit tests to integration tests
size: XLarge
parallel: false
depends_on: [015, 016]
status: pending
created: 2025-09-20T02:15:00Z
updated: 2025-09-20T02:15:00Z
---

# Task 017: Convert over-mocked unit tests to integration tests

## Objective

Convert heavily mocked unit tests to proper integration tests that use real
implementations, moving them to the appropriate test tier while maintaining
coverage and improving test quality.

## Background

Tests with extensive mocking are often integration tests disguised as unit
tests. By converting them to proper integration tests with real implementations,
we achieve better test coverage, catch real bugs, and reduce maintenance
overhead while improving overall test quality.

## Requirements

### 1. Over-Mocked Test Identification

Identify unit tests that should be integration tests:

- Tests with >3 mocks (after applying promotion rules)
- Tests mocking multiple layers of the application
- Tests that verify complex workflows or business processes
- Tests that mock external dependencies heavily

### 2. Integration Test Conversion

Transform identified tests by:

- Moving from `__tests__/unit/` to `__tests__/integration/`
- Replacing mocks with real implementations
- Setting up proper test infrastructure (database, file system, etc.)
- Restructuring test scenarios for integration testing
- Ensuring proper test isolation and cleanup

### 3. Test Quality Improvement

Enhance converted tests:

- Use realistic test data and scenarios
- Test actual business workflows end-to-end
- Verify real interactions between components
- Maintain performance within integration test limits
- Add proper error handling and edge case testing

## Implementation Details

### 1. Over-Mocked Test Analysis

```typescript
// scripts/over-mocked-test-analyzer.ts

interface OverMockedTest {
  file: string
  testName: string
  mockCount: number
  mockComplexity: number
  businessValue: 'high' | 'medium' | 'low'
  conversionComplexity: 'simple' | 'moderate' | 'complex'
  integrationPotential: 'excellent' | 'good' | 'poor'
  requiredInfrastructure: InfrastructureRequirement[]
  estimatedConversionTime: 'small' | 'medium' | 'large'
  blockers: string[]
  dependencies: string[]
}

interface InfrastructureRequirement {
  type: 'database' | 'filesystem' | 'http' | 'time' | 'external-service'
  complexity: 'simple' | 'moderate' | 'complex'
  setup: string
}

class OverMockedTestAnalyzer {
  async analyzeOverMockedTests(testDir: string): Promise<OverMockedTest[]> {
    const unitTestFiles = await this.findUnitTestFiles(testDir)
    const overMockedTests: OverMockedTest[] = []

    for (const file of unitTestFiles) {
      const content = await fs.readFile(file, 'utf-8')
      const tests = this.extractTests(content)

      for (const test of tests) {
        const mockAnalysis = this.analyzeMockUsage(content, test)

        if (this.isOverMocked(mockAnalysis)) {
          const overMockedTest = await this.analyzeForConversion(
            file,
            test,
            mockAnalysis,
          )
          overMockedTests.push(overMockedTest)
        }
      }
    }

    return this.prioritizeByConversionValue(overMockedTests)
  }

  private isOverMocked(mockAnalysis: MockAnalysis): boolean {
    return (
      mockAnalysis.mockCount > 3 ||
      mockAnalysis.complexMockCount > 1 ||
      mockAnalysis.layersMocked > 2 ||
      mockAnalysis.workflowComplexity > 0.7
    )
  }

  private async analyzeForConversion(
    file: string,
    test: TestInfo,
    mockAnalysis: MockAnalysis,
  ): Promise<OverMockedTest> {
    const businessValue = this.assessBusinessValue(test, mockAnalysis)
    const infrastructure = this.analyzeInfrastructureRequirements(mockAnalysis)
    const dependencies = this.extractDependencies(mockAnalysis)

    return {
      file,
      testName: test.name,
      mockCount: mockAnalysis.mockCount,
      mockComplexity: mockAnalysis.complexMockCount,
      businessValue,
      conversionComplexity: this.assessConversionComplexity(
        mockAnalysis,
        infrastructure,
      ),
      integrationPotential: this.assessIntegrationPotential(
        mockAnalysis,
        dependencies,
      ),
      requiredInfrastructure: infrastructure,
      estimatedConversionTime: this.estimateConversionTime(
        mockAnalysis,
        infrastructure,
      ),
      blockers: this.identifyConversionBlockers(mockAnalysis, dependencies),
      dependencies,
    }
  }

  private assessBusinessValue(
    test: TestInfo,
    mockAnalysis: MockAnalysis,
  ): 'high' | 'medium' | 'low' {
    // High value: Tests business workflows, user-facing features
    if (
      test.name.includes('workflow') ||
      test.name.includes('process') ||
      test.name.includes('integration') ||
      mockAnalysis.layersMocked >= 3
    ) {
      return 'high'
    }

    // Medium value: Tests important business logic
    if (mockAnalysis.mockCount >= 4 || mockAnalysis.workflowComplexity > 0.5) {
      return 'medium'
    }

    return 'low'
  }

  private analyzeInfrastructureRequirements(
    mockAnalysis: MockAnalysis,
  ): InfrastructureRequirement[] {
    const requirements: InfrastructureRequirement[] = []

    if (mockAnalysis.databaseMocks > 0) {
      requirements.push({
        type: 'database',
        complexity: mockAnalysis.databaseMocks > 2 ? 'complex' : 'simple',
        setup: 'setupTestDatabase',
      })
    }

    if (mockAnalysis.fileMocks > 0) {
      requirements.push({
        type: 'filesystem',
        complexity: mockAnalysis.fileMocks > 3 ? 'complex' : 'simple',
        setup: 'setupFileSystem',
      })
    }

    if (mockAnalysis.httpMocks > 0) {
      requirements.push({
        type: 'http',
        complexity: mockAnalysis.httpMocks > 2 ? 'complex' : 'simple',
        setup: 'setupMswServer',
      })
    }

    if (mockAnalysis.timeMocks > 0) {
      requirements.push({
        type: 'time',
        complexity: 'simple',
        setup: 'setupDeterministicTime',
      })
    }

    if (mockAnalysis.externalServiceMocks > 0) {
      requirements.push({
        type: 'external-service',
        complexity:
          mockAnalysis.externalServiceMocks > 1 ? 'complex' : 'moderate',
        setup: 'setupExternalServiceMocks',
      })
    }

    return requirements
  }

  private assessIntegrationPotential(
    mockAnalysis: MockAnalysis,
    dependencies: string[],
  ): 'excellent' | 'good' | 'poor' {
    const internalMockRatio =
      mockAnalysis.internalMocks / mockAnalysis.mockCount
    const hasExternalDependencies = dependencies.some((dep) =>
      this.isExternalDependency(dep),
    )

    if (internalMockRatio > 0.8 && !hasExternalDependencies) {
      return 'excellent'
    }

    if (internalMockRatio > 0.6 && mockAnalysis.externalServiceMocks <= 2) {
      return 'good'
    }

    return 'poor'
  }

  private prioritizeByConversionValue(
    tests: OverMockedTest[],
  ): OverMockedTest[] {
    return tests.sort((a, b) => {
      const valueScore = { high: 3, medium: 2, low: 1 }
      const potentialScore = { excellent: 3, good: 2, poor: 1 }
      const complexityScore = { simple: 3, moderate: 2, complex: 1 }

      const aScore =
        valueScore[a.businessValue] *
        potentialScore[a.integrationPotential] *
        complexityScore[a.conversionComplexity]

      const bScore =
        valueScore[b.businessValue] *
        potentialScore[b.integrationPotential] *
        complexityScore[b.conversionComplexity]

      return bScore - aScore
    })
  }
}
```

### 2. Integration Test Conversion Engine

```typescript
// scripts/integration-test-converter.ts

class IntegrationTestConverter {
  async convertToIntegrationTest(
    test: OverMockedTest,
  ): Promise<ConversionResult> {
    try {
      // Step 1: Analyze the current test structure
      const testContent = await fs.readFile(test.file, 'utf-8')
      const testStructure = this.parseTestStructure(testContent, test.testName)

      // Step 2: Create integration test structure
      const integrationTest = await this.createIntegrationTest(
        testStructure,
        test,
      )

      // Step 3: Set up test infrastructure
      const infrastructure = this.setupTestInfrastructure(
        test.requiredInfrastructure,
      )

      // Step 4: Replace mocks with real implementations
      const withRealImplementations = this.replaceWithRealImplementations(
        integrationTest,
        testStructure.mocks,
      )

      // Step 5: Add proper test data and scenarios
      const withTestData = this.addRealisticTestData(
        withRealImplementations,
        test,
      )

      // Step 6: Add cleanup and isolation
      const finalTest = this.addTestIsolation(
        withTestData,
        test.requiredInfrastructure,
      )

      return {
        success: true,
        integrationTestContent: finalTest,
        infrastructureSetup: infrastructure,
        testLocation: this.determineIntegrationTestLocation(test.file),
        originalTestRemoval: this.generateOriginalTestRemoval(test),
        changes: this.summarizeChanges(test),
      }
    } catch (error) {
      return {
        success: false,
        error: error.message,
        fallbackStrategy: 'manual-conversion',
      }
    }
  }

  private async createIntegrationTest(
    testStructure: TestStructure,
    test: OverMockedTest,
  ): Promise<string> {
    const integrationTestTemplate = `
import { describe, test, expect, beforeEach, afterEach } from 'vitest'
${this.generateInfrastructureImports(test.requiredInfrastructure)}
${this.generateBusinessLogicImports(test.dependencies)}
${this.generateTestDataImports()}

describe('${this.generateIntegrationTestSuiteName(test)}', () => {
  ${this.generateInfrastructureSetup(test.requiredInfrastructure)}

  beforeEach(async () => {
    ${this.generateBeforeEachSetup(test.requiredInfrastructure)}
  })

  afterEach(async () => {
    ${this.generateAfterEachCleanup(test.requiredInfrastructure)}
  })

  ${this.generateIntegrationTestCases(testStructure, test)}
})
    `

    return integrationTestTemplate
  }

  private generateInfrastructureImports(
    requirements: InfrastructureRequirement[],
  ): string {
    const imports: string[] = []

    requirements.forEach((req) => {
      switch (req.type) {
        case 'database':
          imports.push(
            "import { setupTestDatabase } from '../../fixtures/utils/database'",
          )
          break
        case 'filesystem':
          imports.push(
            "import { setupFileSystem } from '../../fixtures/utils/filesystem'",
          )
          break
        case 'http':
          imports.push(
            "import { setupMswServer } from '../../fixtures/servers/msw-server'",
          )
          break
        case 'time':
          imports.push(
            "import { setupDeterministicTime } from '../../fixtures/utils/time'",
          )
          break
        case 'external-service':
          imports.push(
            "import { setupExternalServiceMocks } from '../../fixtures/mocks/external-services'",
          )
          break
      }
    })

    return imports.join('\n')
  }

  private generateInfrastructureSetup(
    requirements: InfrastructureRequirement[],
  ): string {
    const setups: string[] = []

    requirements.forEach((req) => {
      switch (req.type) {
        case 'database':
          setups.push('const { db, cleanup: cleanupDb } = setupTestDatabase()')
          break
        case 'filesystem':
          setups.push('const fs = setupFileSystem()')
          break
        case 'http':
          setups.push('const server = setupMswServer()')
          break
        case 'time':
          setups.push('const time = setupDeterministicTime()')
          break
        case 'external-service':
          setups.push('const externalMocks = setupExternalServiceMocks()')
          break
      }
    })

    return setups.join('\n  ')
  }

  private generateIntegrationTestCases(
    testStructure: TestStructure,
    test: OverMockedTest,
  ): string {
    // Convert the original test case to integration test scenarios
    const scenarios = this.identifyTestScenarios(testStructure)

    return scenarios
      .map((scenario) => this.generateScenarioTest(scenario, test))
      .join('\n\n  ')
  }

  private generateScenarioTest(
    scenario: TestScenario,
    test: OverMockedTest,
  ): string {
    return `
  test('${scenario.name}', async () => {
    // Arrange: Set up test data and environment
    ${this.generateTestDataSetup(scenario, test)}

    // Act: Execute the business workflow
    ${this.generateBusinessWorkflowExecution(scenario, test)}

    // Assert: Verify the complete workflow results
    ${this.generateIntegrationAssertions(scenario, test)}
  })
    `
  }

  private generateTestDataSetup(
    scenario: TestScenario,
    test: OverMockedTest,
  ): string {
    const setups: string[] = []

    if (test.requiredInfrastructure.some((req) => req.type === 'database')) {
      setups.push(`
    // Set up test data in database
    const testUser = await db.users.create({
      id: 'test-user-1',
      name: 'Test User',
      email: 'test@example.com'
    })

    const testProject = await db.projects.create({
      id: 'test-project-1',
      name: 'Test Project',
      ownerId: testUser.id
    })
      `)
    }

    if (test.requiredInfrastructure.some((req) => req.type === 'filesystem')) {
      setups.push(`
    // Set up test files
    const configFile = fs.createTestFile('config.json', JSON.stringify({
      projectId: testProject.id,
      settings: { autoSave: true }
    }))

    const dataDir = fs.tempDir.createDir('data')
      `)
    }

    if (test.requiredInfrastructure.some((req) => req.type === 'http')) {
      setups.push(`
    // Set up HTTP service expectations
    server.use(
      http.get('/api/external/validate', () => {
        return HttpResponse.json({ valid: true, score: 95 })
      })
    )
      `)
    }

    return setups.join('\n')
  }

  private generateBusinessWorkflowExecution(
    scenario: TestScenario,
    test: OverMockedTest,
  ): string {
    // Generate the actual business logic execution without mocks
    const className = this.extractMainClassName(test.dependencies)
    const constructorArgs = this.generateConstructorArgs(
      test.requiredInfrastructure,
    )

    return `
    // Create service with real dependencies
    const service = new ${className}(${constructorArgs})

    // Execute the business workflow
    const result = await service.${scenario.mainAction}(${scenario.actionArgs})
    `
  }

  private generateConstructorArgs(
    requirements: InfrastructureRequirement[],
  ): string {
    const args: string[] = []

    requirements.forEach((req) => {
      switch (req.type) {
        case 'database':
          args.push('db')
          break
        case 'filesystem':
          args.push('fs.tempDir.path')
          break
        case 'http':
          args.push('{ apiUrl: server.info.url }')
          break
        case 'external-service':
          args.push('externalMocks.config')
          break
      }
    })

    return args.join(', ')
  }

  private generateIntegrationAssertions(
    scenario: TestScenario,
    test: OverMockedTest,
  ): string {
    const assertions: string[] = []

    // Business logic assertions
    assertions.push(`
    // Verify business logic results
    expect(result.success).toBe(true)
    expect(result.data).toBeDefined()
    `)

    // Database state assertions
    if (test.requiredInfrastructure.some((req) => req.type === 'database')) {
      assertions.push(`
    // Verify database state changes
    const updatedProject = await db.projects.findById(testProject.id)
    expect(updatedProject.status).toBe('processed')
    expect(updatedProject.lastModified).toBeDefined()
      `)
    }

    // File system assertions
    if (test.requiredInfrastructure.some((req) => req.type === 'filesystem')) {
      assertions.push(`
    // Verify file system changes
    expect(fs.tempDir.exists('data/output.json')).toBe(true)
    const outputData = JSON.parse(fs.tempDir.readFile('data/output.json'))
    expect(outputData.projectId).toBe(testProject.id)
      `)
    }

    // HTTP interaction assertions
    if (test.requiredInfrastructure.some((req) => req.type === 'http')) {
      assertions.push(`
    // Verify external service interactions
    expect(server.getHandlers()).toHaveBeenCalledWith(
      expect.objectContaining({
        url: expect.stringContaining('/api/external/validate')
      })
    )
      `)
    }

    return assertions.join('\n')
  }

  private replaceWithRealImplementations(
    testContent: string,
    mocks: MockInfo[],
  ): string {
    let updatedContent = testContent

    // Remove all mock setups
    mocks.forEach((mock) => {
      updatedContent = this.removeMockSetup(updatedContent, mock)
    })

    // Replace mock usage with real instantiation
    updatedContent = this.replaceConstructorCalls(updatedContent, mocks)

    // Remove mock expectations and replace with real assertions
    updatedContent = this.replaceMockExpectations(updatedContent, mocks)

    return updatedContent
  }

  private addRealisticTestData(
    testContent: string,
    test: OverMockedTest,
  ): string {
    // Add realistic test data builders and scenarios
    const testDataImport =
      "import { createRealisticTestScenario } from '../../fixtures/scenarios'"

    const testDataSetup = `
    // Create realistic test scenario
    const scenario = createRealisticTestScenario('${this.inferScenarioType(test)}', {
      complexity: '${test.conversionComplexity}',
      includeEdgeCases: true
    })
    `

    return this.addToTestSetup(testContent, testDataImport, testDataSetup)
  }

  private addTestIsolation(
    testContent: string,
    requirements: InfrastructureRequirement[],
  ): string {
    const isolationSetup = requirements
      .map((req) => {
        switch (req.type) {
          case 'database':
            return 'await cleanupDb()'
          case 'filesystem':
            return 'fs.cleanup()'
          case 'http':
            return 'server.resetHandlers()'
          case 'time':
            return 'time.reset()'
          case 'external-service':
            return 'externalMocks.reset()'
          default:
            return ''
        }
      })
      .filter(Boolean)
      .join('\n    ')

    return this.addToAfterEach(testContent, isolationSetup)
  }

  private determineIntegrationTestLocation(originalFile: string): string {
    // Convert unit test path to integration test path
    return originalFile
      .replace('/__tests__/unit/', '/__tests__/integration/')
      .replace('/unit/', '/integration/')
  }
}
```

### 3. Test Infrastructure Enhancement

```typescript
// Enhanced test infrastructure for integration tests
// __tests__/fixtures/scenarios/realistic-test-scenarios.ts

export class RealisticTestScenarioBuilder {
  static createRealisticTestScenario(
    type: string,
    options: ScenarioOptions = {},
  ): TestScenario {
    const scenarios = {
      'user-management': this.createUserManagementScenario,
      'file-processing': this.createFileProcessingScenario,
      'data-pipeline': this.createDataPipelineScenario,
      'workflow-execution': this.createWorkflowExecutionScenario,
      'integration-flow': this.createIntegrationFlowScenario,
    }

    const scenarioBuilder = scenarios[type] || scenarios['integration-flow']
    return scenarioBuilder(options)
  }

  private static createUserManagementScenario(
    options: ScenarioOptions,
  ): TestScenario {
    return {
      name: 'Complete user management workflow',
      description: 'Tests user creation, validation, and notification flow',
      testData: {
        users: [
          {
            id: 'user-1',
            name: 'John Doe',
            email: 'john.doe@example.com',
            role: 'admin',
            preferences: { theme: 'dark', notifications: true },
          },
          {
            id: 'user-2',
            name: 'Jane Smith',
            email: 'jane.smith@example.com',
            role: 'user',
            preferences: { theme: 'light', notifications: false },
          },
        ],
        organizations: [
          {
            id: 'org-1',
            name: 'Test Organization',
            settings: { allowPublicAccess: false },
          },
        ],
      },
      expectedOutcomes: {
        database: {
          usersCreated: 2,
          organizationMemberships: 2,
          auditLogs: 4,
        },
        notifications: {
          emailsSent: 1, // Only user with notifications enabled
          webhooksCalled: 1,
        },
        files: {
          configUpdated: true,
          backupCreated: true,
        },
      },
      edgeCases: options.includeEdgeCases
        ? [
            'duplicate email handling',
            'invalid organization assignment',
            'notification service failure',
          ]
        : [],
    }
  }

  private static createFileProcessingScenario(
    options: ScenarioOptions,
  ): TestScenario {
    return {
      name: 'End-to-end file processing workflow',
      description: 'Tests file upload, processing, validation, and storage',
      testData: {
        files: [
          {
            name: 'test-document.pdf',
            size: 1024 * 1024, // 1MB
            type: 'application/pdf',
            content: 'mock-pdf-content',
          },
          {
            name: 'data.csv',
            size: 512 * 1024, // 512KB
            type: 'text/csv',
            content:
              'id,name,email\n1,John,john@example.com\n2,Jane,jane@example.com',
          },
        ],
        processingRules: {
          maxFileSize: 5 * 1024 * 1024, // 5MB
          allowedTypes: ['application/pdf', 'text/csv', 'image/jpeg'],
          virusScanEnabled: true,
          thumbnailGeneration: true,
        },
      },
      expectedOutcomes: {
        storage: {
          filesStored: 2,
          thumbnailsGenerated: 1,
          metadataExtracted: 2,
        },
        database: {
          fileRecordsCreated: 2,
          processingLogsCreated: 4,
        },
        external: {
          virusScanCalls: 2,
          notificationsSent: 1,
        },
      },
    }
  }

  private static createDataPipelineScenario(
    options: ScenarioOptions,
  ): TestScenario {
    return {
      name: 'Data pipeline integration workflow',
      description:
        'Tests data ingestion, transformation, validation, and export',
      testData: {
        inputData: [
          {
            source: 'api',
            format: 'json',
            data: { users: 100, projects: 50, tasks: 500 },
          },
          {
            source: 'csv',
            format: 'csv',
            data: 'Raw CSV data with 1000 records',
          },
        ],
        transformationRules: {
          deduplication: true,
          validation: ['email', 'phone', 'date'],
          enrichment: ['geolocation', 'demographics'],
          formatting: ['standardizeNames', 'normalizePhones'],
        },
      },
      expectedOutcomes: {
        processing: {
          recordsProcessed: 1600,
          recordsValid: 1580,
          recordsEnriched: 1580,
          duplicatesRemoved: 20,
        },
        database: {
          tablesUpdated: 3,
          indexesRebuilt: 2,
          statisticsUpdated: true,
        },
        exports: {
          reportsGenerated: 2,
          notificationsSent: 1,
          filesCreated: 3,
        },
      },
    }
  }
}

interface TestScenario {
  name: string
  description: string
  testData: any
  expectedOutcomes: any
  edgeCases?: string[]
}

interface ScenarioOptions {
  complexity?: 'simple' | 'moderate' | 'complex'
  includeEdgeCases?: boolean
  customData?: any
}
```

### 4. Progress Tracking and Quality Metrics

```typescript
// Track conversion progress and quality improvements
class IntegrationConversionTracker {
  async trackConversionProgress(
    originalTests: OverMockedTest[],
    conversionResults: ConversionResult[],
  ): Promise<ConversionMetrics> {
    const successful = conversionResults.filter((r) => r.success)
    const failed = conversionResults.filter((r) => !r.success)

    const qualityMetrics = await this.calculateQualityMetrics(successful)
    const performanceImpact = await this.assessPerformanceImpact(successful)
    const coverageImpact = await this.analyzeCoverageImpact(successful)

    return {
      totalTargetTests: originalTests.length,
      testsConverted: successful.length,
      testsFailed: failed.length,
      mocksEliminated: this.countMocksEliminated(successful),
      integrationTestsCreated: successful.length,
      qualityMetrics,
      performanceImpact,
      coverageImpact,
      businessValueAchieved: this.calculateBusinessValue(successful),
    }
  }

  private async calculateQualityMetrics(
    results: ConversionResult[],
  ): Promise<QualityMetrics> {
    return {
      realImplementationUsage: results.length, // All converted tests use real implementations
      workflowCoverageImprovement: this.calculateWorkflowCoverage(results),
      bugDetectionImprovement: this.estimateBugDetectionImprovement(results),
      maintenanceReduction: this.calculateMaintenanceReduction(results),
      testReliabilityImprovement: await this.measureTestReliability(results),
    }
  }

  private async assessPerformanceImpact(
    results: ConversionResult[],
  ): Promise<PerformanceImpact> {
    const performanceData = await this.gatherPerformanceData(results)

    return {
      averageExecutionTime: performanceData.averageTime,
      memoryUsage: performanceData.memoryUsage,
      setupTeardownTime: performanceData.setupTime,
      parallelizationImpact: performanceData.parallelization,
      ciExecutionTime: performanceData.ciTime,
    }
  }

  generateConversionReport(metrics: ConversionMetrics): string {
    return `
# Integration Test Conversion Report

## Conversion Summary
- **Total Over-Mocked Tests**: ${metrics.totalTargetTests}
- **Successfully Converted**: ${metrics.testsConverted}
- **Conversion Failures**: ${metrics.testsFailed}
- **Success Rate**: ${((metrics.testsConverted / metrics.totalTargetTests) * 100).toFixed(1)}%
- **Mocks Eliminated**: ${metrics.mocksEliminated}
- **New Integration Tests**: ${metrics.integrationTestsCreated}

## Quality Improvements
- **Real Implementation Usage**: 100% (all converted tests)
- **Workflow Coverage Improvement**: ${metrics.qualityMetrics.workflowCoverageImprovement}%
- **Bug Detection Improvement**: ${metrics.qualityMetrics.bugDetectionImprovement}%
- **Maintenance Reduction**: ${metrics.qualityMetrics.maintenanceReduction}%
- **Test Reliability Improvement**: ${metrics.qualityMetrics.testReliabilityImprovement}%

## Performance Impact
- **Average Execution Time**: ${metrics.performanceImpact.averageExecutionTime}ms
- **Memory Usage**: ${metrics.performanceImpact.memoryUsage}MB
- **Setup/Teardown Time**: ${metrics.performanceImpact.setupTeardownTime}ms
- **CI Execution Time Impact**: ${metrics.performanceImpact.ciExecutionTime}

## Coverage Impact
- **Integration Coverage Increase**: ${metrics.coverageImpact.integrationIncrease}%
- **Unit Coverage Change**: ${metrics.coverageImpact.unitCoverageChange}%
- **Overall Coverage Change**: ${metrics.coverageImpact.overallChange}%
- **Real Bug Coverage**: ${metrics.coverageImpact.realBugCoverage}%

## Business Value Achieved
- **High-Value Workflows Tested**: ${metrics.businessValueAchieved.highValueWorkflows}
- **Critical Path Coverage**: ${metrics.businessValueAchieved.criticalPathCoverage}%
- **User Journey Validation**: ${metrics.businessValueAchieved.userJourneyValidation}%
- **Integration Risk Reduction**: ${metrics.businessValueAchieved.riskReduction}%

## Key Benefits Realized

### 1. Realistic Testing
- Tests now validate actual business workflows
- Real component interactions are tested
- Integration bugs are caught before production

### 2. Maintenance Reduction
- Eliminated ${metrics.mocksEliminated} complex mock setups
- Reduced mock maintenance overhead by ${metrics.qualityMetrics.maintenanceReduction}%
- Simplified test debugging and troubleshooting

### 3. Improved Confidence
- Tests validate real code paths
- Integration scenarios are thoroughly tested
- Deployment confidence significantly increased

### 4. Better Bug Detection
- Integration tests catch real interaction bugs
- Performance issues are identified during testing
- Data flow problems are detected early

## Recommendations

1. **Monitor Performance**: Keep integration test execution under 5 seconds per test
2. **Expand Coverage**: Convert remaining over-mocked tests in phases
3. **Team Training**: Ensure team understands integration testing patterns
4. **Continuous Improvement**: Regularly review and optimize integration tests

## Next Steps

1. Address failed conversions through manual intervention
2. Optimize slow integration tests for better performance
3. Expand integration test coverage to remaining areas
4. Establish guidelines to prevent over-mocking in new tests
    `
  }
}

interface ConversionMetrics {
  totalTargetTests: number
  testsConverted: number
  testsFailed: number
  mocksEliminated: number
  integrationTestsCreated: number
  qualityMetrics: QualityMetrics
  performanceImpact: PerformanceImpact
  coverageImpact: CoverageImpact
  businessValueAchieved: BusinessValue
}
```

## Acceptance Criteria

- [ ] Over-mocked unit tests identified and prioritized by business value
- [ ] Conversion complexity assessed for each candidate test
- [ ] Infrastructure requirements analyzed and documented
- [ ] Integration test conversion engine created and tested
- [ ] Tests successfully moved from unit to integration directories
- [ ] All mocks replaced with real implementations in converted tests
- [ ] Proper test infrastructure set up (database, file system, HTTP, etc.)
- [ ] Realistic test data and scenarios implemented
- [ ] Test isolation and cleanup mechanisms added
- [ ] Performance impact assessed and optimized
- [ ] At least 75% of high-value over-mocked tests successfully converted
- [ ] Quality metrics tracking system implemented
- [ ] Conversion progress reporting created
- [ ] Team documentation updated with integration testing patterns

## Benefits

1. **Realistic Testing**: Tests now validate actual business workflows
2. **Better Bug Detection**: Integration tests catch real interaction issues
3. **Reduced Maintenance**: Eliminated complex mock setups and maintenance
4. **Improved Confidence**: Tests validate real code paths and integrations
5. **Quality Assurance**: Integration scenarios are thoroughly validated

## Notes

- This is one of the most impactful tasks in mock reduction
- Focus on high-business-value tests first for maximum impact
- Monitor performance closely as integration tests are typically slower
- Ensure proper test isolation to prevent flaky tests
- Consider breaking this into smaller phases for manageable implementation
