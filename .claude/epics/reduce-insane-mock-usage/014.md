---
name: Consolidate repetitive mock patterns into factories
status: open
created: 2025-09-20T01:15:53Z
updated: 2025-09-20T01:15:53Z
github: [Will be updated when synced to GitHub]
depends_on: [011]
parallel: true
conflicts_with: []
---

# Task 014: Consolidate repetitive mock patterns into factories

## Description

Identify and consolidate repetitive mock patterns across the codebase into reusable mock factories. This reduces code duplication, improves consistency, and makes mock management more maintainable while preparing for eventual mock reduction.

Create centralized mock factories that can generate consistent, well-structured mocks for common patterns, reducing the overall complexity and maintenance burden of the mocking infrastructure.

## Acceptance Criteria

1. **Pattern Identification**
   - [ ] Identify all repetitive mock patterns across 66 test files
   - [ ] Categorize patterns by complexity and frequency
   - [ ] Document mock pattern variations and requirements
   - [ ] Prioritize patterns by consolidation impact

2. **Mock Factory Creation**
   - [ ] Create reusable factories for high-frequency patterns
   - [ ] Implement configurable mock generators
   - [ ] Develop type-safe mock builders
   - [ ] Establish consistent naming conventions

3. **Pattern Consolidation**
   - [ ] Replace repetitive mock setups with factory calls
   - [ ] Migrate existing tests to use new factories
   - [ ] Maintain test functionality and coverage
   - [ ] Reduce overall mock-related code volume

4. **Documentation and Standards**
   - [ ] Document available mock factories and usage patterns
   - [ ] Create guidelines for when to create new factories
   - [ ] Establish standards for factory design and naming
   - [ ] Provide migration guides for common patterns

## Technical Details

### Common Mock Patterns to Consolidate

1. **File System Mock Patterns**
   ```typescript
   // BEFORE - Repetitive file system mocking
   // Found in multiple test files:
   vi.mock('fs/promises', () => ({
     readFile: vi.fn().mockResolvedValue('file content'),
     writeFile: vi.fn().mockResolvedValue(undefined),
     mkdir: vi.fn().mockResolvedValue(undefined),
     stat: vi.fn().mockResolvedValue({ isDirectory: () => false })
   }));
   
   // AFTER - Consolidated factory
   export const createFileSystemMock = (overrides = {}) => ({
     readFile: vi.fn().mockResolvedValue('default content'),
     writeFile: vi.fn().mockResolvedValue(undefined),
     mkdir: vi.fn().mockResolvedValue(undefined),
     stat: vi.fn().mockResolvedValue({ isDirectory: () => false }),
     ...overrides
   });
   ```

2. **API Response Mock Patterns**
   ```typescript
   // BEFORE - Repetitive API mocking
   // Found across many test files:
   const mockResponse = {
     ok: true,
     status: 200,
     json: vi.fn().mockResolvedValue({ data: 'test' })
   };
   
   // AFTER - Configurable response factory
   export const createApiResponseMock = (
     data: any = { data: 'default' },
     status = 200,
     ok = true
   ) => ({
     ok,
     status,
     statusText: ok ? 'OK' : 'Error',
     json: vi.fn().mockResolvedValue(data),
     text: vi.fn().mockResolvedValue(JSON.stringify(data))
   });
   ```

3. **Logger Mock Patterns**
   ```typescript
   // BEFORE - Repetitive logger setup
   const mockLogger = {
     info: vi.fn(),
     error: vi.fn(),
     warn: vi.fn(),
     debug: vi.fn()
   };
   
   // AFTER - Logger factory with tracking
   export const createLoggerMock = () => {
     const calls = { info: [], error: [], warn: [], debug: [] };
     return {
       info: vi.fn().mockImplementation((msg) => calls.info.push(msg)),
       error: vi.fn().mockImplementation((msg) => calls.error.push(msg)),
       warn: vi.fn().mockImplementation((msg) => calls.warn.push(msg)),
       debug: vi.fn().mockImplementation((msg) => calls.debug.push(msg)),
       getCalls: () => calls
     };
   };
   ```

4. **Database Mock Patterns**
   ```typescript
   // BEFORE - Complex database mocking
   const mockDb = {
     query: vi.fn(),
     transaction: vi.fn(),
     insert: vi.fn().mockResolvedValue({ id: 1 }),
     update: vi.fn().mockResolvedValue({ affected: 1 }),
     delete: vi.fn().mockResolvedValue({ affected: 1 })
   };
   
   // AFTER - Database factory with fluent interface
   export class DatabaseMockBuilder {
     private mocks = {
       query: vi.fn(),
       transaction: vi.fn(),
       insert: vi.fn(),
       update: vi.fn(),
       delete: vi.fn()
     };
   
     withQueryResult(result: any) {
       this.mocks.query.mockResolvedValue(result);
       return this;
     }
   
     withInsertId(id: number) {
       this.mocks.insert.mockResolvedValue({ id });
       return this;
     }
   
     build() {
       return this.mocks;
     }
   }
   ```

### Factory Design Principles

1. **Configurability**
   - Provide sensible defaults
   - Allow targeted overrides
   - Support both simple and complex configurations
   - Maintain type safety

2. **Consistency**
   - Standardized return formats
   - Consistent error handling patterns
   - Uniform naming conventions
   - Predictable behavior

3. **Composability**
   - Factories can work together
   - Builders for complex scenarios
   - Chainable configurations
   - Modular design

4. **Maintainability**
   - Clear documentation
   - Self-contained factories
   - Easy to extend
   - Version compatibility

### Implementation Strategy

1. **Pattern Analysis Phase**
   ```bash
   # Identify repetitive mock patterns
   grep -r "vi\.mock\|jest\.mock" --include="*.test.ts" . | \
     awk -F: '{print $2}' | sort | uniq -c | sort -nr
   
   # Find common mock implementations
   grep -r "mockImplementation\|mockResolvedValue" --include="*.test.ts" . | \
     grep -E "(readFile|writeFile|fetch|query)" | sort
   ```

2. **Factory Development**
   - Create `/test/factories/` directory
   - Implement individual factories for each pattern
   - Add TypeScript types and interfaces
   - Include comprehensive documentation

3. **Migration Strategy**
   - Start with highest-frequency patterns
   - Migrate tests incrementally
   - Maintain backward compatibility during transition
   - Validate no functionality regression

4. **Quality Assurance**
   - Test factories themselves
   - Ensure migrated tests maintain coverage
   - Validate performance impact
   - Check for any breaking changes

### Factory Organization

```
test/
├── factories/
│   ├── api-mocks.ts          # HTTP/API response factories
│   ├── database-mocks.ts     # Database operation factories
│   ├── filesystem-mocks.ts   # File system operation factories
│   ├── logger-mocks.ts       # Logging system factories
│   ├── service-mocks.ts      # External service factories
│   └── index.ts              # Centralized exports
├── utils/
│   └── mock-helpers.ts       # Utility functions for mocking
└── setup/
    └── factory-setup.ts      # Global factory configuration
```

## Dependencies

- **Task 011**: Mock audit must identify repetitive patterns to consolidate
- **No Conflicts**: Factory creation is additive and safe for parallel execution

## Effort Estimate

**Size**: Large (3 days)

**Breakdown**:
- Day 1: Pattern analysis and factory design
- Day 2: Factory implementation and testing
- Day 3: Migration of existing tests to use factories

**Skills Required**:
- Pattern recognition and abstraction
- TypeScript factory design
- Test refactoring expertise
- API design for developer experience

## Definition of Done

1. **Factory Infrastructure**
   - Complete set of mock factories for identified patterns
   - Type-safe interfaces and builders
   - Comprehensive documentation and examples
   - Integration with existing test framework

2. **Pattern Consolidation**
   - Significant reduction in repetitive mock code
   - Consistent mock behavior across tests
   - Improved test setup readability
   - Easier mock maintenance and updates

3. **Migration Success**
   - High-frequency patterns migrated to factories
   - No regression in test functionality or coverage
   - Improved test development velocity
   - Reduced onboarding complexity for new developers

4. **Documentation and Standards**
   - Factory usage guidelines and best practices
   - Migration guide for remaining patterns
   - Design principles for future factory development
   - Integration examples and common use cases

5. **Quality Metrics**
   - Measurable reduction in mock-related code duplication
   - Improved test consistency scores
   - Faster test development times
   - Reduced mock-related test failures

The implementation must demonstrate that mock patterns can be effectively consolidated without losing flexibility, providing a foundation for easier mock management and future reduction efforts.