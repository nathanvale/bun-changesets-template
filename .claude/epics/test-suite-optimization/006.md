---
id: 006
title: Add global teardown hooks
epic: test-suite-optimization
status: ready
priority: high
depends_on: ['004', '005']
parallel: []
estimated_hours: 4
labels:
  - zombie-prevention
  - cleanup
  - test-hooks
---

# Task 006: Add global teardown hooks

## Objective

Implement comprehensive global teardown hooks to ensure all resources are
cleaned up after test execution, even in failure scenarios.

## Background

Tests may not clean up properly when they fail or timeout. We need global
teardown hooks that guarantee cleanup regardless of test outcome.

## Requirements

### Must Have

- [ ] Global teardown for all test runs
- [ ] Cleanup on process exit signals
- [ ] Resource cleanup registry
- [ ] Teardown execution order management
- [ ] Cleanup verification and reporting

### Nice to Have

- [ ] Teardown performance metrics
- [ ] Cleanup failure recovery
- [ ] Resource leak detection

## Implementation Details

### Step 1: Create global teardown manager

Create `packages/quality-check/src/teardown-manager.ts`:

```typescript
interface TeardownTask {
  id: string
  priority: number // Lower numbers run first
  handler: () => Promise<void>
  timeout: number
  critical: boolean // Must complete even if others fail
}

class TeardownManager {
  private tasks: Map<string, TeardownTask> = new Map()
  private executed = false

  register(task: TeardownTask): void {
    this.tasks.set(task.id, task)
  }

  async executeAll(): Promise<void> {
    if (this.executed) return // Prevent double execution
    this.executed = true

    const sortedTasks = Array.from(this.tasks.values()).sort(
      (a, b) => a.priority - b.priority,
    )

    const results = []
    for (const task of sortedTasks) {
      try {
        await this.executeTask(task)
        results.push({ task: task.id, status: 'success' })
      } catch (error) {
        results.push({ task: task.id, status: 'failed', error })
        if (task.critical) {
          throw new Error(`Critical teardown task failed: ${task.id}`)
        }
      }
    }

    console.log('Teardown complete:', results)
  }

  private async executeTask(task: TeardownTask): Promise<void> {
    return Promise.race([
      task.handler(),
      new Promise((_, reject) =>
        setTimeout(() => reject(new Error('Teardown timeout')), task.timeout),
      ),
    ])
  }
}
```

### Step 2: Register default teardown tasks

Create `vitest.globalTeardown.ts`:

```typescript
import { teardownManager } from './teardown-manager'

export default async function globalTeardown() {
  // Register cleanup tasks
  teardownManager.register({
    id: 'kill-zombies',
    priority: 1,
    handler: async () => {
      const zombies = await processTracker.getZombieProcesses()
      for (const zombie of zombies) {
        await processTracker.terminateProcess(zombie.pid)
      }
    },
    timeout: 5000,
    critical: true,
  })

  teardownManager.register({
    id: 'close-db-connections',
    priority: 2,
    handler: async () => {
      // Close any open database connections
      await closeAllDatabaseConnections()
    },
    timeout: 3000,
    critical: false,
  })

  teardownManager.register({
    id: 'clear-temp-files',
    priority: 3,
    handler: async () => {
      // Clean up temporary test files
      await clearTempTestFiles()
    },
    timeout: 2000,
    critical: false,
  })

  teardownManager.register({
    id: 'report-leaks',
    priority: 999,
    handler: async () => {
      // Report any detected resource leaks
      const leaks = await detectResourceLeaks()
      if (leaks.length > 0) {
        console.warn('Resource leaks detected:', leaks)
      }
    },
    timeout: 1000,
    critical: false,
  })

  // Execute all teardown tasks
  await teardownManager.executeAll()
}
```

### Step 3: Handle process signals

Add signal handlers for unexpected exits:

```typescript
// Register cleanup on process signals
const signals = ['SIGTERM', 'SIGINT', 'SIGUSR1', 'SIGUSR2', 'uncaughtException']

signals.forEach((signal) => {
  process.on(signal, async (error?) => {
    console.log(`Received ${signal}, running emergency cleanup...`)

    if (error) {
      console.error('Error details:', error)
    }

    try {
      // Emergency cleanup
      await teardownManager.executeAll()

      // Force kill any remaining processes
      const remaining = await processTracker.getZombieProcesses()
      remaining.forEach((p) => {
        try {
          process.kill(p.pid, 'SIGKILL')
        } catch {}
      })
    } catch (cleanupError) {
      console.error('Cleanup failed:', cleanupError)
    } finally {
      process.exit(signal === 'SIGTERM' ? 0 : 1)
    }
  })
})
```

### Step 4: Create resource cleanup registry

Implement automatic resource tracking:

```typescript
class ResourceRegistry {
  private resources: Map<string, () => Promise<void>> = new Map()

  register(id: string, cleanup: () => Promise<void>): void {
    this.resources.set(id, cleanup)
  }

  unregister(id: string): void {
    this.resources.delete(id)
  }

  async cleanupAll(): Promise<void> {
    const cleanups = Array.from(this.resources.values())
    await Promise.allSettled(cleanups.map((cleanup) => cleanup()))
    this.resources.clear()
  }
}

// Usage in tests
beforeEach(() => {
  const server = createTestServer()
  resourceRegistry.register(`server-${testId}`, async () => {
    await server.close()
  })
})
```

### Step 5: Add cleanup verification

Verify cleanup effectiveness:

```typescript
async function verifyCleanup(): Promise<CleanupReport> {
  const report = {
    zombieProcesses: 0,
    openHandles: 0,
    memoryLeaks: [],
    tempFiles: 0,
  }

  // Check for zombie processes
  report.zombieProcesses = (await processTracker.getZombieProcesses()).length

  // Check for open handles
  if (process._getActiveHandles) {
    report.openHandles = process._getActiveHandles().length
  }

  // Check for temp files
  report.tempFiles = await countTempFiles()

  return report
}
```

## Acceptance Criteria

- [ ] Global teardown manager implemented
- [ ] Default cleanup tasks registered
- [ ] Signal handlers for unexpected exits
- [ ] Resource registry for automatic cleanup
- [ ] Cleanup verification and reporting

## Testing

- Simulate test failures and verify cleanup
- Kill test process and verify emergency cleanup
- Check Activity Monitor for zombie processes
- Verify all resources are released

## Risks

- Teardown may hang if tasks don't timeout
- Critical cleanup failure could hide test failures
- Signal handlers may interfere with debugging

## Dependencies

- ProcessTracker from Task 004
- Vitest global teardown support
- Node.js process signal handling

## Notes

This provides the safety net for all cleanup operations. Must be bulletproof to
prevent zombie accumulation.
