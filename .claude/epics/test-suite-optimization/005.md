---
id: 005
title: Implement Vitest force-kill configuration
epic: test-suite-optimization
status: ready
priority: high
depends_on: ["004"]
parallel: []
estimated_hours: 4
labels:
  - zombie-prevention
  - vitest-config
  - process-management
---

# Task 005: Implement Vitest force-kill configuration

## Objective

Configure Vitest to aggressively terminate processes that exceed timeouts or don't respond to termination signals.

## Background

Vitest's default termination behavior is too gentle, allowing processes to linger. We need to configure more aggressive termination policies and timeouts.

## Requirements

### Must Have
- [ ] Configure test timeouts with force kill
- [ ] Set up teardown timeouts
- [ ] Implement hanging test detection
- [ ] Add process isolation options
- [ ] Create kill-on-timeout mechanism

### Nice to Have
- [ ] Per-test-type timeout configuration
- [ ] Dynamic timeout adjustment
- [ ] Timeout reporting and analytics

## Implementation Details

### Step 1: Update Vitest configuration
Modify `vitest.config.ts`:
```typescript
export default defineConfig({
  test: {
    // Aggressive timeouts
    testTimeout: 30000, // 30 seconds max per test
    hookTimeout: 10000, // 10 seconds for hooks
    teardownTimeout: 5000, // 5 seconds for teardown

    // Process isolation
    pool: 'forks',
    poolOptions: {
      forks: {
        isolate: true,
        singleFork: false,
        maxForks: 4,
      }
    },

    // Force termination
    dangerouslyIgnoreUnhandledErrors: false,
    bail: 1, // Stop on first failure in CI

    // Custom termination handler
    setupFiles: ['./vitest.force-kill.setup.ts'],
  }
});
```

### Step 2: Create force-kill setup
Create `vitest.force-kill.setup.ts`:
```typescript
import { afterEach, onTestFailed } from 'vitest';

// Track test execution time
let testStartTime: number;

beforeEach(() => {
  testStartTime = Date.now();

  // Set up timeout killer
  const timeoutId = setTimeout(() => {
    console.error('Test timeout - force killing process');
    process.exit(1); // Nuclear option
  }, 30000);

  // Store timeout for cleanup
  (global as any).__timeoutKiller = timeoutId;
});

afterEach(() => {
  // Clear timeout killer
  if ((global as any).__timeoutKiller) {
    clearTimeout((global as any).__timeoutKiller);
  }

  // Log slow tests
  const duration = Date.now() - testStartTime;
  if (duration > 5000) {
    console.warn(`Slow test detected: ${duration}ms`);
  }
});

onTestFailed(() => {
  // Kill any hanging processes on test failure
  if (processTracker) {
    processTracker.terminateAll();
  }
});
```

### Step 3: Implement hanging test detector
Add hanging test detection:
```typescript
class HangingTestDetector {
  private activeTests = new Map<string, NodeJS.Timeout>();

  startTest(testName: string): void {
    const timeout = setTimeout(() => {
      console.error(`Test "${testName}" is hanging - force terminating`);
      this.forceKillTest(testName);
    }, 30000);

    this.activeTests.set(testName, timeout);
  }

  endTest(testName: string): void {
    const timeout = this.activeTests.get(testName);
    if (timeout) {
      clearTimeout(timeout);
      this.activeTests.delete(testName);
    }
  }

  private forceKillTest(testName: string): void {
    // Get all processes for this test
    const processes = processTracker.getProcessesByTest(testName);

    // Force kill all processes
    processes.forEach(p => {
      try {
        process.kill(p.pid, 'SIGKILL');
      } catch (e) {
        // Process may already be dead
      }
    });

    // Exit test runner if needed
    if (this.activeTests.size === 1) {
      process.exit(1);
    }
  }
}
```

### Step 4: Add environment-specific configs
Create different timeout profiles:
```typescript
const timeoutProfiles = {
  unit: {
    testTimeout: 5000,
    hookTimeout: 2000,
  },
  integration: {
    testTimeout: 15000,
    hookTimeout: 5000,
  },
  e2e: {
    testTimeout: 30000,
    hookTimeout: 10000,
  },
  ci: {
    testTimeout: 45000, // More lenient in CI
    hookTimeout: 15000,
  }
};

// Apply based on test type or environment
const profile = process.env.CI ? timeoutProfiles.ci :
                testFile.includes('.integration.') ? timeoutProfiles.integration :
                testFile.includes('.e2e.') ? timeoutProfiles.e2e :
                timeoutProfiles.unit;
```

## Acceptance Criteria

- [ ] Vitest configuration updated with force-kill settings
- [ ] Hanging test detector implemented
- [ ] Tests terminate within configured timeouts
- [ ] No processes survive after timeout
- [ ] Different timeout profiles for test types

## Testing

- Create intentionally hanging test
- Verify test is force-killed after timeout
- Check no zombie processes remain
- Test different timeout scenarios

## Risks

- Aggressive killing may hide real issues
- May terminate tests that are legitimately slow
- Could corrupt test database state

## Dependencies

- Vitest configuration system
- ProcessTracker from Task 004
- Node.js process management

## Notes

Balance between aggressive termination and allowing legitimate long-running tests. Consider making timeouts configurable per test.