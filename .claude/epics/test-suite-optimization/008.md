---
id: 008
title: Test zero-zombie guarantee
epic: test-suite-optimization
status: ready
priority: high
depends_on: ['004', '005', '006', '007']
parallel: []
estimated_hours: 4
labels:
  - zombie-prevention
  - validation
  - testing
---

# Task 008: Test zero-zombie guarantee

## Objective

Thoroughly test and validate that all zombie prevention mechanisms work together
to guarantee zero zombie processes.

## Background

After implementing tracking, force-kill, teardown, and emergency cleanup, we
need comprehensive testing to ensure the zero-zombie guarantee holds under all
conditions.

## Requirements

### Must Have

- [ ] Test normal test completion
- [ ] Test test failure scenarios
- [ ] Test timeout scenarios
- [ ] Test process kill scenarios
- [ ] Continuous run validation (1+ hours)

### Nice to Have

- [ ] Stress testing with many processes
- [ ] Memory leak validation
- [ ] Performance impact measurement

## Implementation Details

### Step 1: Create zombie validation test suite

Create `tests/zombie-prevention.validation.test.ts`:

```typescript
import { describe, it, expect, beforeAll, afterAll } from 'vitest'
import { spawn } from 'child_process'
import { ProcessTracker } from '../src/process-tracker'

describe('Zombie Prevention Validation', () => {
  let initialProcessCount: number

  beforeAll(() => {
    initialProcessCount = getNodeProcessCount()
  })

  afterAll(() => {
    const finalCount = getNodeProcessCount()
    expect(finalCount).toBeLessThanOrEqual(initialProcessCount)
  })

  it('should clean up after normal test completion', async () => {
    const child = spawn('node', ['-e', 'setTimeout(() => {}, 100)'])
    await new Promise((resolve) => setTimeout(resolve, 200))

    const tracker = new ProcessTracker()
    const zombies = tracker.getZombieProcesses()
    expect(zombies).toHaveLength(0)
  })

  it('should clean up after test failure', async () => {
    try {
      throw new Error('Intentional test failure')
    } finally {
      const zombies = await checkForZombies()
      expect(zombies).toHaveLength(0)
    }
  })

  it('should clean up after test timeout', async () => {
    const timeoutPromise = new Promise((resolve) => {
      const timeout = setTimeout(resolve, 60000) // Won't complete
      // Vitest should kill this after 30s
    })

    // This test will be killed by timeout
  }, 35000) // Set slightly higher than kill timeout

  it('should handle multiple child processes', async () => {
    const children = []
    for (let i = 0; i < 10; i++) {
      children.push(spawn('node', ['-e', 'setTimeout(() => {}, 1000)']))
    }

    await new Promise((resolve) => setTimeout(resolve, 2000))

    const zombies = await checkForZombies()
    expect(zombies).toHaveLength(0)
  })
})
```

### Step 2: Create continuous run test

Create `scripts/continuous-test.js`:

```javascript
#!/usr/bin/env node

const { spawn } = require('child_process')
const fs = require('fs')
const path = require('path')

class ContinuousTestRunner {
  constructor() {
    this.startTime = Date.now()
    this.runCount = 0
    this.zombieChecks = []
    this.logFile = path.join(
      '.claude',
      'metrics',
      `continuous-run-${Date.now()}.log`,
    )
  }

  async run(durationMinutes = 60) {
    console.log(`Starting ${durationMinutes}-minute continuous test run`)
    this.log(`Test run started at ${new Date().toISOString()}`)

    const endTime = Date.now() + durationMinutes * 60 * 1000

    while (Date.now() < endTime) {
      await this.runTestSuite()
      await this.checkZombies()
      await this.cooldown()
      this.reportProgress()
    }

    this.generateReport()
  }

  async runTestSuite() {
    return new Promise((resolve, reject) => {
      const start = Date.now()
      const child = spawn('pnpm', ['test'], {
        stdio: 'pipe',
        env: { ...process.env, CI: 'true' },
      })

      let output = ''
      child.stdout.on('data', (data) => {
        output += data.toString()
      })

      child.stderr.on('data', (data) => {
        output += data.toString()
      })

      child.on('close', (code) => {
        const duration = Date.now() - start
        this.runCount++

        this.log(
          `Run #${this.runCount}: ${code === 0 ? 'PASS' : 'FAIL'} (${duration}ms)`,
        )

        if (code !== 0) {
          this.log(`Failed output: ${output.slice(-1000)}`)
        }

        resolve()
      })

      // Force kill if hanging
      setTimeout(() => {
        child.kill('SIGKILL')
        reject(new Error('Test suite timeout'))
      }, 120000) // 2 minute timeout
    })
  }

  async checkZombies() {
    try {
      const output = require('child_process')
        .execSync('ps aux | grep -E "node.*vitest" | grep -v grep | wc -l')
        .toString()
        .trim()

      const count = parseInt(output)
      this.zombieChecks.push({
        time: Date.now(),
        count: count,
        runNumber: this.runCount,
      })

      if (count > 0) {
        this.log(
          `⚠️  WARNING: ${count} zombie processes detected after run #${this.runCount}`,
        )
        // Try emergency cleanup
        this.emergencyCleanup()
      }
    } catch (error) {
      // No zombies found (grep returns error when no matches)
    }
  }

  emergencyCleanup() {
    try {
      require('child_process').execSync('pnpm zombies:kill:force')
      this.log('Emergency cleanup executed')
    } catch (error) {
      this.log(`Emergency cleanup failed: ${error.message}`)
    }
  }

  async cooldown() {
    // Brief cooldown between runs
    await new Promise((resolve) => setTimeout(resolve, 5000))
  }

  reportProgress() {
    const runtime = Math.floor((Date.now() - this.startTime) / 1000 / 60)
    const zombieTotal = this.zombieChecks.reduce(
      (sum, check) => sum + check.count,
      0,
    )

    console.clear()
    console.log('Continuous Test Run Progress')
    console.log('============================')
    console.log(`Runtime: ${runtime} minutes`)
    console.log(`Test Runs: ${this.runCount}`)
    console.log(`Total Zombies: ${zombieTotal}`)
    console.log(`Last Check: ${new Date().toLocaleTimeString()}`)

    if (zombieTotal > 0) {
      console.log('\n⚠️  ZOMBIES DETECTED - Review log for details')
    }
  }

  generateReport() {
    const report = {
      duration: Date.now() - this.startTime,
      totalRuns: this.runCount,
      zombieChecks: this.zombieChecks,
      maxZombies: Math.max(...this.zombieChecks.map((c) => c.count)),
      totalZombies: this.zombieChecks.reduce(
        (sum, check) => sum + check.count,
        0,
      ),
    }

    const reportPath = path.join(
      '.claude',
      'metrics',
      `continuous-report-${Date.now()}.json`,
    )
    fs.writeFileSync(reportPath, JSON.stringify(report, null, 2))

    console.log('\n\nFinal Report')
    console.log('============')
    console.log(`Total Runs: ${report.totalRuns}`)
    console.log(`Total Zombies: ${report.totalZombies}`)
    console.log(`Max Zombies at Once: ${report.maxZombies}`)
    console.log(`Report saved: ${reportPath}`)

    if (report.totalZombies === 0) {
      console.log('\n✅ ZERO ZOMBIE GUARANTEE VALIDATED!')
    } else {
      console.log('\n❌ ZOMBIE PREVENTION FAILED')
      process.exit(1)
    }
  }

  log(message) {
    const timestamp = new Date().toISOString()
    const logEntry = `[${timestamp}] ${message}\n`
    fs.appendFileSync(this.logFile, logEntry)
  }
}

// Run if executed directly
if (require.main === module) {
  const runner = new ContinuousTestRunner()
  const duration = parseInt(process.argv[2]) || 60
  runner.run(duration).catch(console.error)
}

module.exports = ContinuousTestRunner
```

### Step 3: Create stress test

Create `tests/zombie-stress.test.ts`:

```typescript
describe('Zombie Prevention Stress Test', () => {
  it('should handle 100 concurrent processes', async () => {
    const processes = []

    // Spawn 100 processes
    for (let i = 0; i < 100; i++) {
      processes.push(
        spawn('node', [
          '-e',
          `
        const id = ${i};
        setInterval(() => {
          console.log('Process', id, 'alive');
        }, 100);
      `,
        ]),
      )
    }

    // Let them run
    await new Promise((resolve) => setTimeout(resolve, 5000))

    // Should all be cleaned up after test
  }, 30000)

  it('should handle process fork bombs', async () => {
    // Create a process that spawns children
    const forkBomb = spawn('node', [
      '-e',
      `
      const { spawn } = require('child_process');
      for (let i = 0; i < 10; i++) {
        spawn('node', ['-e', 'setTimeout(() => {}, 10000)']);
      }
    `,
    ])

    await new Promise((resolve) => setTimeout(resolve, 2000))

    // All should be cleaned up
  })
})
```

### Step 4: Add validation npm scripts

Update `package.json`:

```json
{
  "scripts": {
    "test:zombie-validation": "vitest run tests/zombie-prevention.validation.test.ts",
    "test:zombie-stress": "vitest run tests/zombie-stress.test.ts",
    "test:continuous": "node scripts/continuous-test.js 60",
    "test:continuous:quick": "node scripts/continuous-test.js 10",
    "validate:zombies": "npm run test:zombie-validation && npm run test:zombie-stress && npm run test:continuous:quick"
  }
}
```

## Acceptance Criteria

- [ ] Validation test suite passes
- [ ] Stress tests handle 100+ processes
- [ ] Continuous run for 1+ hours with zero zombies
- [ ] Emergency cleanup works when triggered
- [ ] Detailed report of validation results

## Testing

- Run each validation test individually
- Run full validation suite
- Monitor Activity Monitor during tests
- Check process cleanup after each test
- Verify reports are generated

## Risks

- Stress tests may overwhelm system
- Continuous run may find edge cases
- Different behavior in CI vs local

## Dependencies

- All previous zombie prevention tasks
- ProcessTracker implementation
- Emergency cleanup scripts
- Vitest test runner

## Notes

This is the final validation of zombie prevention. Must pass consistently before
considering the zombie problem solved.
