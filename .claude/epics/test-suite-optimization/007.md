---
id: 007
title: Create emergency cleanup script
epic: test-suite-optimization
status: ready
priority: high
depends_on: ["004"]
parallel: ["008"]
estimated_hours: 3
labels:
  - zombie-prevention
  - cli-tools
  - emergency-recovery
---

# Task 007: Create emergency cleanup script

## Objective

Create a standalone emergency script to kill all test-related processes when automatic cleanup fails.

## Background

When zombie processes accumulate and automatic cleanup fails, developers need a nuclear option to clean their system without restarting.

## Requirements

### Must Have
- [ ] Kill all node/vitest processes
- [ ] Safe mode to preserve non-test processes
- [ ] Dry-run mode to preview actions
- [ ] Process count before/after cleanup
- [ ] Work across macOS/Linux

### Nice to Have
- [ ] Windows support
- [ ] Process age filtering
- [ ] Memory usage reporting
- [ ] Integration with VS Code

## Implementation Details

### Step 1: Create emergency cleanup script
Create `scripts/emergency-cleanup.sh`:
```bash
#!/bin/bash

# Emergency Zombie Process Cleanup Script
# Usage: ./emergency-cleanup.sh [--force] [--dry-run]

set -e

FORCE_MODE=false
DRY_RUN=false

# Parse arguments
while [[ $# -gt 0 ]]; do
  case $1 in
    --force)
      FORCE_MODE=true
      shift
      ;;
    --dry-run)
      DRY_RUN=true
      shift
      ;;
    *)
      echo "Unknown option: $1"
      echo "Usage: $0 [--force] [--dry-run]"
      exit 1
      ;;
  esac
done

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

echo -e "${YELLOW}🧟 Zombie Process Emergency Cleanup${NC}"
echo "=================================="

# Count current zombies
ZOMBIE_COUNT=$(ps aux | grep -E "node.*vitest" | grep -v grep | wc -l | tr -d ' ')
echo -e "Found ${RED}$ZOMBIE_COUNT${NC} potential zombie processes"

if [ "$ZOMBIE_COUNT" -eq 0 ]; then
  echo -e "${GREEN}✓ No zombie processes found${NC}"
  exit 0
fi

# Show processes that will be killed
echo -e "\n${YELLOW}Processes to be terminated:${NC}"
ps aux | grep -E "node.*vitest" | grep -v grep

if [ "$DRY_RUN" = true ]; then
  echo -e "\n${YELLOW}DRY RUN: No processes will be killed${NC}"
  exit 0
fi

# Confirm before killing (unless force mode)
if [ "$FORCE_MODE" = false ]; then
  echo -e "\n${RED}⚠️  WARNING: This will kill $ZOMBIE_COUNT processes${NC}"
  read -p "Continue? (y/n): " -n 1 -r
  echo
  if [[ ! $REPLY =~ ^[Yy]$ ]]; then
    echo "Aborted"
    exit 1
  fi
fi

# Kill processes
echo -e "\n${YELLOW}Terminating processes...${NC}"

# First try SIGTERM
ps aux | grep -E "node.*vitest" | grep -v grep | awk '{print $2}' | while read pid; do
  echo "  Sending SIGTERM to PID $pid"
  kill -TERM $pid 2>/dev/null || true
done

# Wait a moment
sleep 2

# Then SIGKILL any remaining
REMAINING=$(ps aux | grep -E "node.*vitest" | grep -v grep | wc -l | tr -d ' ')
if [ "$REMAINING" -gt 0 ]; then
  echo -e "${YELLOW}Force killing $REMAINING stubborn processes...${NC}"
  ps aux | grep -E "node.*vitest" | grep -v grep | awk '{print $2}' | while read pid; do
    echo "  Sending SIGKILL to PID $pid"
    kill -9 $pid 2>/dev/null || true
  done
fi

# Verify cleanup
sleep 1
FINAL_COUNT=$(ps aux | grep -E "node.*vitest" | grep -v grep | wc -l | tr -d ' ')

if [ "$FINAL_COUNT" -eq 0 ]; then
  echo -e "\n${GREEN}✅ Successfully cleaned up all zombie processes${NC}"
  echo -e "Killed: ${RED}$ZOMBIE_COUNT${NC} processes"
else
  echo -e "\n${RED}❌ Failed to kill all processes${NC}"
  echo -e "Remaining: ${RED}$FINAL_COUNT${NC} processes"
  exit 1
fi
```

### Step 2: Create Node.js version
Create `scripts/emergency-cleanup.js`:
```javascript
#!/usr/bin/env node

const { exec, execSync } = require('child_process');
const readline = require('readline');

const colors = {
  red: '\x1b[31m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  reset: '\x1b[0m'
};

class EmergencyCleanup {
  constructor(options = {}) {
    this.force = options.force || false;
    this.dryRun = options.dryRun || false;
    this.verbose = options.verbose || false;
  }

  async findZombies() {
    try {
      const output = execSync('ps aux | grep -E "node.*vitest" | grep -v grep', {
        encoding: 'utf8'
      });

      return output.split('\n').filter(line => line.trim()).map(line => {
        const parts = line.split(/\s+/);
        return {
          user: parts[0],
          pid: parseInt(parts[1]),
          cpu: parseFloat(parts[2]),
          mem: parseFloat(parts[3]),
          command: parts.slice(10).join(' ')
        };
      });
    } catch (error) {
      return []; // No processes found
    }
  }

  async killProcess(pid, signal = 'SIGTERM') {
    return new Promise((resolve) => {
      exec(`kill -${signal} ${pid}`, (error) => {
        resolve(!error);
      });
    });
  }

  async cleanup() {
    console.log(`${colors.yellow}🧟 Zombie Process Emergency Cleanup${colors.reset}`);
    console.log('==================================');

    const zombies = await this.findZombies();
    console.log(`Found ${colors.red}${zombies.length}${colors.reset} zombie processes`);

    if (zombies.length === 0) {
      console.log(`${colors.green}✓ No zombie processes found${colors.reset}`);
      return;
    }

    // Show processes
    console.log('\nProcesses to be terminated:');
    zombies.forEach(z => {
      console.log(`  PID ${z.pid}: ${z.command.substring(0, 50)}...`);
    });

    if (this.dryRun) {
      console.log(`\n${colors.yellow}DRY RUN: No processes will be killed${colors.reset}`);
      return;
    }

    if (!this.force) {
      const confirmed = await this.confirm(
        `\n${colors.red}⚠️  Kill ${zombies.length} processes?${colors.reset} (y/n): `
      );
      if (!confirmed) {
        console.log('Aborted');
        return;
      }
    }

    // Kill processes
    console.log(`\n${colors.yellow}Terminating processes...${colors.reset}`);

    // First pass: SIGTERM
    for (const zombie of zombies) {
      await this.killProcess(zombie.pid, 'SIGTERM');
      if (this.verbose) {
        console.log(`  Sent SIGTERM to PID ${zombie.pid}`);
      }
    }

    // Wait for graceful termination
    await new Promise(resolve => setTimeout(resolve, 2000));

    // Second pass: SIGKILL remaining
    const remaining = await this.findZombies();
    if (remaining.length > 0) {
      console.log(`${colors.yellow}Force killing ${remaining.length} stubborn processes...${colors.reset}`);
      for (const zombie of remaining) {
        await this.killProcess(zombie.pid, 'SIGKILL');
        if (this.verbose) {
          console.log(`  Sent SIGKILL to PID ${zombie.pid}`);
        }
      }
    }

    // Verify
    await new Promise(resolve => setTimeout(resolve, 1000));
    const final = await this.findZombies();

    if (final.length === 0) {
      console.log(`\n${colors.green}✅ Successfully cleaned up all zombie processes${colors.reset}`);
      console.log(`Killed: ${colors.red}${zombies.length}${colors.reset} processes`);
    } else {
      console.log(`\n${colors.red}❌ Failed to kill all processes${colors.reset}`);
      console.log(`Remaining: ${colors.red}${final.length}${colors.reset} processes`);
      process.exit(1);
    }
  }

  confirm(prompt) {
    return new Promise((resolve) => {
      const rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout
      });

      rl.question(prompt, (answer) => {
        rl.close();
        resolve(answer.toLowerCase() === 'y');
      });
    });
  }
}

// CLI interface
if (require.main === module) {
  const args = process.argv.slice(2);
  const options = {
    force: args.includes('--force'),
    dryRun: args.includes('--dry-run'),
    verbose: args.includes('--verbose')
  };

  const cleanup = new EmergencyCleanup(options);
  cleanup.cleanup().catch(console.error);
}

module.exports = EmergencyCleanup;
```

### Step 3: Add npm scripts
Update `package.json`:
```json
{
  "scripts": {
    "zombies:kill": "node scripts/emergency-cleanup.js",
    "zombies:kill:force": "node scripts/emergency-cleanup.js --force",
    "zombies:check": "node scripts/emergency-cleanup.js --dry-run",
    "emergency": "npm run zombies:kill:force"
  }
}
```

## Acceptance Criteria

- [ ] Shell script created and executable
- [ ] Node.js version for cross-platform support
- [ ] Dry-run mode shows processes without killing
- [ ] Force mode skips confirmation
- [ ] NPM scripts for easy access

## Testing

- Create zombie processes intentionally
- Run script in dry-run mode
- Run script with confirmation
- Run script in force mode
- Verify all zombies are killed

## Risks

- May kill legitimate long-running processes
- User may accidentally kill important processes
- Different process names on different systems

## Dependencies

- Unix process management tools
- Node.js for cross-platform version
- grep, ps, kill commands

## Notes

This is the safety net when all else fails. Make it foolproof and well-documented.